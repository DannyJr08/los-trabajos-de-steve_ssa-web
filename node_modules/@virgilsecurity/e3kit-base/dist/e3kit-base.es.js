/**
 * BSD 3-Clause License
 * 
 * Copyright (c) 2018-2020, Virgil Security, Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 * 
 * * Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import { VirgilAgent, KeyEntryAlreadyExistsError } from 'virgil-sdk';
import { KeyknoxManager, KeyknoxCrypto, KeyknoxClient, CloudGroupTicketStorage, CloudEntryDoesntExistError, CloudKeyStorage } from '@virgilsecurity/keyknox';
import levelup from 'levelup';
import sub from 'subleveldown';
import { AbstractLevelDOWN, AbstractIterator } from 'abstract-leveldown';
import { PythiaClient, BrainKey } from 'virgil-pythia';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/**
 * @hidden
 */
function hasDuplicates(array) {
    return new Set(array).size !== array.length;
}
/**
 * @hidden
 */
function getObjectValues(obj) {
    if (Object.values)
        return Object.values(obj);
    return Object.keys(obj).map(function (e) {
        return obj[e];
    });
}
/**
 * @hidden
 *
 * Splits the `array` into separate chunks of the specified `size`
 *
 * @param array
 * @param size
 */
function chunkArray(array, size) {
    size = Math.max(size, 0);
    const length = array == null ? 0 : array.length;
    if (!length || size < 1) {
        return [];
    }
    let index = 0;
    let resIndex = 0;
    const result = Array(Math.ceil(length / size));
    while (index < length) {
        result[resIndex++] = array.slice(index, (index += size));
    }
    return result;
}

/**
 * Custom error class for errors specific to Virgil E3kit.
 */
class SdkError extends Error {
    constructor(m, name = 'SdkError', DerivedClass = SdkError) {
        super(m);
        Object.setPrototypeOf(this, DerivedClass.prototype);
        this.name = name;
    }
}
/**
 * Error thrown by {@link EThree.register} when identity is already registered on Virgil Cloud.
 * To load private key use EThree.restorePrivateKey or EThree.rotatePrivateKey.
 */
class IdentityAlreadyExistsError extends SdkError {
    constructor() {
        super('This identity is already registered on Virgil Cloud. To load private key use EThree.restorePrivateKey or EThree.rotatePrivateKey', 'IdentityAlreadyExistsError', IdentityAlreadyExistsError);
    }
}
/**
 * Error thrown by  {@link Ethree.unregister} and {@link EThree.rotatePrivateKey}
 * when current identity of E3kit instance is not registered (i.e. there is
 * no Virgil Card for the current identity in Virgil Cloud).
 */
class RegisterRequiredError extends SdkError {
    constructor() {
        super('This identity is not registered', 'RegisterRequiredError', RegisterRequiredError);
    }
}
/**
 * Error thrown by {@link EThree.backupPrivateKey},  {@link EThree.changePassword} and
 * {@link EThree.resetPrivateKeyBackup} when user enters wrong password.
 */
class WrongKeyknoxPasswordError extends SdkError {
    constructor() {
        super('Password from remote private key storage is invalid', 'WrongKeyknoxPasswordError', WrongKeyknoxPasswordError);
    }
}
/**
 * Error thrown by {@link EThree.rotatePrivateKey} and {@link EThree.restorePrivateKey}
 */
class PrivateKeyAlreadyExistsError extends SdkError {
    constructor() {
        super('You already have a private key. Use EThree.cleanup() to delete it. If you delete the last copy of the private key, you will not be able to decrypt any information encrypted for this private key', 'PrivateKeyAlreadyExistsError', PrivateKeyAlreadyExistsError);
    }
}
/**
 * Error thrown by {@link EThree.resetPrivateKeyBackup} when backup copy of private key doesn't exist
 */
class PrivateKeyNoBackupError extends SdkError {
    constructor() {
        super("Backup copy of private key doesn't exist", 'PrivateKeyNoBackupError', PrivateKeyNoBackupError);
    }
}
/**
 * Error thrown by {@link EThree.register}, {@link EThree.rotatePrivateKey} and {@link EThree.lookupPublicKeys}
 * when one user has more then one card.
 */
class MultipleCardsError extends SdkError {
    constructor(identity) {
        super(`There are several public keys registered with ${identity}, which is not supported.`, 'MultipleCardsError', MultipleCardsError);
        this.identity = identity;
    }
}
/**
 * Error thrown by {@link EThree.lookupPublicKeys} in case if some identity missing or has multiple cards.
 *
 * @deprecated and will be removed in next major release.
 */
class LookupError extends SdkError {
    constructor(lookupResult) {
        super('Failed some public keys lookups. You can see the results by calling error.lookupResult property of this error instance', 'LookupError', LookupError);
        this.lookupResult = lookupResult;
    }
}
/**
 * Error thrown by {@link EThree.lookupPublicKeys} in case if sought identity is not registered.
 *
 * @deprecated and will be removed in next major release.
 */
class LookupNotFoundError extends SdkError {
    constructor(identity) {
        super(`${identity} not found`, 'LookupNotFoundError', LookupNotFoundError);
        this.identity = identity;
    }
}
/**
 * Error thrown by {@link EThree.decryptFile} in case if signature of the file is not valid.
 */
class IntegrityCheckFailedError extends SdkError {
    constructor(message) {
        super(message, 'IntegrityCheckFailedError', IntegrityCheckFailedError);
    }
}
/**
 * Error thrown by {@link EThree.decryptFile} or {@link EThree.encryptFile} if user aborts an operation.
 */
class AbortError extends SdkError {
    constructor() {
        super('Operation aborted by user', 'AbortError', AbortError);
    }
}
/**
 * Error thrown by {@link EThree.findUsers} when some of the users's Virgil Cards weren't found.
 */
class UsersNotFoundError extends SdkError {
    constructor(identities) {
        super("Virgil Cards of some of the users weren't found in Virgil Cloud.\n" +
            'Check the "identities" property of this error to see their identites', 'UsersNotFoundError', UsersNotFoundError);
        this.identities = identities;
    }
}
/**
 * Error thrown by {@link EThree.findUsers} when some of the users found have more than one Virgil Card,
 * which is not allowed.
 */
class UsersFoundWithMultipleCardsError extends SdkError {
    constructor(identities) {
        super('Some of the users have multiple Virgil Cards in Virgil Cloud, which is not allowed.' +
            'Check the "identities" property of this error to see their identities', 'UsersFoundWithMultipleCardsError', UsersFoundWithMultipleCardsError);
        this.identities = identities;
    }
}
var GroupErrorCode;
(function (GroupErrorCode) {
    GroupErrorCode[GroupErrorCode["LocalGroupNotFound"] = 1] = "LocalGroupNotFound";
    GroupErrorCode[GroupErrorCode["PermissionDenied"] = 2] = "PermissionDenied";
    GroupErrorCode[GroupErrorCode["RemoteGroupNotFound"] = 3] = "RemoteGroupNotFound";
    GroupErrorCode[GroupErrorCode["InvalidGroup"] = 4] = "InvalidGroup";
    GroupErrorCode[GroupErrorCode["InvalidChangeParticipants"] = 5] = "InvalidChangeParticipants";
    GroupErrorCode[GroupErrorCode["InvalidParticipantsCount"] = 6] = "InvalidParticipantsCount";
    GroupErrorCode[GroupErrorCode["DataVerificationFailed"] = 7] = "DataVerificationFailed";
    GroupErrorCode[GroupErrorCode["GroupIdTooShort"] = 8] = "GroupIdTooShort";
    GroupErrorCode[GroupErrorCode["MessageNotFromThisGroup"] = 9] = "MessageNotFromThisGroup";
    GroupErrorCode[GroupErrorCode["GroupIsOutdated"] = 10] = "GroupIsOutdated";
    GroupErrorCode[GroupErrorCode["NoAccess"] = 11] = "NoAccess";
    GroupErrorCode[GroupErrorCode["ParticipantAlreadyAdded"] = 12] = "ParticipantAlreadyAdded";
})(GroupErrorCode || (GroupErrorCode = {}));
class GroupError extends SdkError {
    constructor(errorCode, message) {
        super(message, 'GroupError', GroupError);
        this.errorCode = errorCode;
    }
}
/**
 * Error thrown when an attempt is made to retrieve the private key from the
 * device's persistent storage, but no private key exists.
 *
 * Thrown by {@link EThree.encrypt}, {@link EThree.decrypt}, {@link EThree.backupPrivateKey},
 * {@link EThree.createGroup}, {@link EThree.loadGroup}, {@link EThree.getGroup},
 * {@link Group.encrypt}, {@link Group.decrypt}, {@link Group.update}, {@link Group.add},
 * {@link Group.remove} and {@link Group.reAdd}.
 */
class MissingPrivateKeyError extends SdkError {
    constructor() {
        super('No private key found on the device. You should call "register()" of "restorePrivateKey()"', 'MissingPrivateKeyError', MissingPrivateKeyError);
    }
}

/**
 * @hidden
 */
const isArray = (val) => {
    return Array.isArray(val);
};
/**
 * @hidden
 */
const isString = (val) => {
    return typeof val === 'string';
};
/**
 * @hidden
 */
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
/**
 * @hidden
 */
function isVirgilCard(obj) {
    return isObject(obj) && 'identity' in obj && 'publicKey' in obj;
}
/**
 * @hidden
 */
function isFindUsersResult(obj) {
    if (!isObject(obj))
        return false;
    const values = getObjectValues(obj);
    if (values.length === 0)
        return false;
    return values.every(val => isVirgilCard(val));
}
/**
 * @hidden
 */
function isLookupResult(obj, isPublicKeyFn) {
    if (!isObject(obj))
        return false;
    const values = getObjectValues(obj);
    if (values.length === 0)
        return false;
    return values.every(val => isPublicKeyFn(val));
}

/**
 * @hidden
 */
const DEFAULT_STORAGE_NAME = '.virgil-local-storage';
/**
 * @hidden
 */
const DEFAULT_GROUP_STORAGE_NAME = '.virgil-group-storage';
/**
 * @hidden
 */
const DEFAULT_API_URL = 'https://api.virgilsecurity.com';
/**
 * @hidden
 */
const MAX_IDENTITIES_TO_SEARCH = 50;
/**
 * @hidden
 */
const CLOUD_GROUP_SESSIONS_ROOT = 'group-sessions';
/**
 * @hidden
 */
const VALID_GROUP_PARTICIPANT_COUNT_RANGE = [1, 100];
/**
 * @hidden
 */
const MAX_EPOCHS_IN_GROUP_SESSION = 50;

function warn(message) {
    if (typeof console !== 'undefined' && typeof console.warn === 'function') {
        console.warn(message);
    }
}

const DATE_TAG = '[object Date]';
const toString = Object.prototype.toString;
/**
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function isValidDate(date) {
    return date && toString.call(date) === DATE_TAG && !isNaN(date);
}

/**
 * @hidden
 */
function getCardActiveAtMoment(card, activeAt) {
    if (!activeAt) {
        return card;
    }
    const activeAtDate = new Date(activeAt);
    if (!isValidDate(activeAtDate)) {
        throw new TypeError('Cannot get active card. Second argument, if provided, must be a Date or a timestamp');
    }
    let actualCard = card;
    while (actualCard && actualCard.createdAt > activeAt) {
        actualCard = actualCard.previousCard;
    }
    if (!actualCard) {
        throw new Error('The given sender Virgil Card is newer than the encrypted data.' +
            'This may happen if they un-registered and registered again with the same identity.' +
            'Try loading their Virgil Card by its ID.');
    }
    return actualCard;
}
/**
 * @hidden
 */
const getCardsArray = (cardOrFindUsersResult) => {
    if (isVirgilCard(cardOrFindUsersResult)) {
        return [cardOrFindUsersResult];
    }
    if (isFindUsersResult(cardOrFindUsersResult)) {
        return getObjectValues(cardOrFindUsersResult);
    }
    return [];
};

/**
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isInteger = (val) => {
    if (Number.isInteger)
        return Number.isInteger(val);
    return typeof val === 'number' && isFinite(val) && Math.floor(val) === val;
};
/**
 * @hidden
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const isSafeInteger = (val) => {
    if (Number.isSafeInteger)
        return Number.isSafeInteger(val);
    return isInteger(val) && Math.abs(val) <= Number.MAX_SAFE_INTEGER;
};
/**
 * @hidden
 */
const isNumberInRange = (num, range) => {
    return typeof num === 'number' && num >= range[0] && num <= range[1];
};

/**
 * @hidden
 */
const setDifference = (a, b) => {
    return new Set([...a].filter(it => !b.has(it)));
};

const isValidParticipantCount = (count) => {
    return isNumberInRange(count, VALID_GROUP_PARTICIPANT_COUNT_RANGE);
};
class Group {
    constructor(options) {
        const sortedTickets = options.tickets
            .slice()
            .sort((a, b) => a.groupSessionMessage.epochNumber - b.groupSessionMessage.epochNumber);
        const lastTicket = sortedTickets[sortedTickets.length - 1];
        if (!lastTicket) {
            throw new GroupError(GroupErrorCode.InvalidGroup, 'Failed to construct Group. Group must have at least one ticket.');
        }
        if (!isValidParticipantCount(lastTicket.participants.length)) {
            throw new GroupError(GroupErrorCode.InvalidParticipantsCount, `Cannot initialize group with ${lastTicket.participants.length} participant(s). Group can have ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[0]} to ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[1]} participants.`);
        }
        this.selfIdentity = options.privateKeyLoader.identity;
        this.initiator = options.initiator;
        this.participants = lastTicket.participants;
        this._virgilCrypto = options.privateKeyLoader.options.virgilCrypto;
        this._privateKeyLoader = options.privateKeyLoader;
        this._session = this._virgilCrypto.importGroupSession(sortedTickets.map(t => t.groupSessionMessage.data));
        this._cardManager = options.cardManager;
        this._groupManager = options.groupManager;
    }
    encrypt(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldReturnString = isString(data);
            const privateKey = yield this._privateKeyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            const encrypted = this._session.encrypt(data, privateKey);
            return shouldReturnString ? encrypted.toString('base64') : encrypted;
        });
    }
    decrypt(encryptedData, senderCard, encryptedAt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { sessionId: messageSessionId, epochNumber: messageEpochNumber, data: messageData, } = this._session.parseMessage(encryptedData);
            if (!isVirgilCard(senderCard)) {
                throw new TypeError('Cannot decrypt data. Second argument must be a Virgil Card object.');
            }
            const shouldReturnString = isString(encryptedData);
            const actualCard = encryptedAt
                ? getCardActiveAtMoment(senderCard, encryptedAt)
                : senderCard;
            if (messageSessionId !== this._session.getSessionId()) {
                throw new GroupError(GroupErrorCode.MessageNotFromThisGroup, 'The given message was encrypted for different group');
            }
            if (messageEpochNumber > this._session.getCurrentEpochNumber()) {
                throw new GroupError(GroupErrorCode.GroupIsOutdated, 'This group is out of date. Call "group.update()" or "e3kitInstance.loadGroup()" to be able to decrypt this message');
            }
            try {
                let decrypted;
                if (this._session.getCurrentEpochNumber() - messageEpochNumber <
                    MAX_EPOCHS_IN_GROUP_SESSION) {
                    decrypted = this._session.decrypt(messageData, actualCard.publicKey);
                }
                else {
                    const tempGroup = yield this._groupManager.retrieve(messageSessionId, messageEpochNumber);
                    if (!tempGroup) {
                        throw new GroupError(GroupErrorCode.LocalGroupNotFound, `Group with given id was not found in local storage. Try to load it first.`);
                    }
                    decrypted = tempGroup.decrypt(encryptedData, actualCard);
                }
                return shouldReturnString ? decrypted.toString('utf8') : decrypted;
            }
            catch (err) {
                if (err.name === 'FoundationError' && /Invalid signature/.test(err.message)) {
                    throw new GroupError(GroupErrorCode.DataVerificationFailed, "Verification of message integrity failed. This may be caused by the sender's public key rotation." +
                        'Try looking it up again with "e3kitInstance.findUsers()"');
                }
                throw err;
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = this._session.getSessionId();
            const initiatorCards = yield this._cardManager.searchCards(this.initiator);
            if (initiatorCards.length === 0) {
                throw new UsersNotFoundError([this.initiator]);
            }
            const group = yield this._groupManager.pull(sessionId, initiatorCards[0]);
            this._session = group._session;
            this.participants = group.participants;
        });
    }
    add(cardOrFindUsersResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const cardsToAdd = getCardsArray(cardOrFindUsersResult);
            if (cardsToAdd.length === 0) {
                throw new TypeError('Failed to add participants. First argument must be the result of "eThree.findUsers" method');
            }
            if (!this.isEditable()) {
                throw new GroupError(GroupErrorCode.PermissionDenied, 'Only group initiator can add participants to the group');
            }
            const missingIdentities = setDifference(new Set(cardsToAdd.map(c => c.identity)), new Set(this.participants));
            const newParticipantCount = missingIdentities.size + this.participants.length;
            if (!isValidParticipantCount(newParticipantCount)) {
                throw new GroupError(GroupErrorCode.InvalidChangeParticipants, `Cannot add ${missingIdentities.size} participant(s) to the group that has ${this.participants.length} participants. Group can have ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[0]} to ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[1]} participants.`);
            }
            const missingCards = cardsToAdd.filter(c => missingIdentities.has(c.identity));
            if (missingCards.length === 0) {
                throw new GroupError(GroupErrorCode.ParticipantAlreadyAdded, `Failed to add participant(s). Participant(s) have already been added.`);
            }
            yield this._groupManager.addAccess(this._session.getSessionId(), missingCards);
            this.participants = [...this.participants, ...missingIdentities];
        });
    }
    remove(cardOrFindUsersResult) {
        return __awaiter(this, void 0, void 0, function* () {
            const cardsToRemove = getCardsArray(cardOrFindUsersResult);
            if (cardsToRemove.length === 0) {
                throw new TypeError('Failed to remove participants. First argument must be the result of "eThree.findUsers" method');
            }
            if (!this.isEditable()) {
                throw new GroupError(GroupErrorCode.PermissionDenied, 'Only group initiator can remove participants from the group');
            }
            const oldIdentities = new Set(this.participants);
            const newIdentities = setDifference(new Set(this.participants), new Set(cardsToRemove.map(c => c.identity)));
            if (!isValidParticipantCount(newIdentities.size)) {
                throw new GroupError(GroupErrorCode.InvalidChangeParticipants, `Cannot remove ${oldIdentities.size -
                    newIdentities.size} participant(s) from the group that has ${oldIdentities.size} participants. Group can have ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[0]} to ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[1]} participants.`);
            }
            if (newIdentities.size === oldIdentities.size) {
                // none of the identities to remove is in the existing participants set
                throw new GroupError(GroupErrorCode.InvalidChangeParticipants, 'Attempted to remove non-existent group participants');
            }
            const newCards = yield this._cardManager.searchCards([...newIdentities]);
            const epochMessage = this._session.addNewEpoch();
            const ticket = { groupSessionMessage: epochMessage, participants: [...newIdentities] };
            yield this._groupManager.store(ticket, newCards);
            newIdentities.add(this.initiator);
            this.participants = [...newIdentities];
            const removedIdentities = setDifference(oldIdentities, newIdentities);
            yield this._groupManager.removeAccess(this._session.getSessionId(), [...removedIdentities]);
        });
    }
    reAdd(participantCard) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!isVirgilCard(participantCard)) {
                throw new TypeError('Failed to re-add participant. First argument must be a Virgil Card object');
            }
            if (!this.isEditable()) {
                throw new GroupError(GroupErrorCode.PermissionDenied, 'Only group initiator can add or remove participants from the group');
            }
            yield this._groupManager.reAddAccess(this._session.getSessionId(), participantCard);
        });
    }
    isEditable() {
        return this.initiator === this.selfIdentity;
    }
}

class GroupManager {
    constructor({ identity, privateKeyLoader, cardManager, groupLocalStorage, }) {
        this._selfIdentity = identity;
        this._privateKeyLoader = privateKeyLoader;
        this._cardManager = cardManager;
        this._localGroupStorage = groupLocalStorage;
    }
    store(ticket, cards) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudTicketStorage = yield this.getCloudTicketStorage();
            yield cloudTicketStorage.store(ticket.groupSessionMessage, cards);
            const group = new Group({
                initiator: this.selfIdentity,
                tickets: [ticket],
                privateKeyLoader: this._privateKeyLoader,
                cardManager: this._cardManager,
                groupManager: this,
            });
            const localGroupStorage = yield this.getLocalGroupStorage();
            localGroupStorage.store({
                info: { initiator: this.selfIdentity },
                tickets: [ticket],
            });
            return group;
        });
    }
    pull(sessionId, initiatorCard) {
        return __awaiter(this, void 0, void 0, function* () {
            const localGroupStorage = yield this.getLocalGroupStorage();
            let cloudTickets;
            try {
                const cloudTicketStorage = yield this.getCloudTicketStorage();
                cloudTickets = yield cloudTicketStorage.retrieve(sessionId, initiatorCard.identity, initiatorCard.publicKey);
            }
            catch (err) {
                if (err.name === 'GroupTicketDoesntExistError' ||
                    err.name === 'GroupTicketNoAccessError') {
                    yield localGroupStorage.delete(sessionId);
                }
                switch (err.name) {
                    case 'GroupTicketDoesntExistError':
                        throw new GroupError(GroupErrorCode.NoAccess, 'Current user has no access to the group ticket');
                    case 'GroupTicketNoAccessError':
                        throw new GroupError(GroupErrorCode.RemoteGroupNotFound, 'Group with given id and initiator could not be found');
                    default:
                        throw err;
                }
            }
            const initiator = initiatorCard.identity;
            const tickets = cloudTickets.map(ct => ({
                groupSessionMessage: ct.groupSessionMessageInfo,
                participants: ct.identities,
            }));
            const group = new Group({
                initiator,
                tickets,
                privateKeyLoader: this._privateKeyLoader,
                cardManager: this._cardManager,
                groupManager: this,
            });
            localGroupStorage.store({ info: { initiator }, tickets });
            return group;
        });
    }
    retrieve(sessionId, epochNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = isSafeInteger(epochNumber)
                ? { epochNumber }
                : { ticketCount: MAX_EPOCHS_IN_GROUP_SESSION };
            const localGroupStorage = yield this.getLocalGroupStorage();
            try {
                const rawGroup = yield localGroupStorage.retrieve(sessionId, options);
                if (!rawGroup)
                    return null;
                return new Group({
                    initiator: rawGroup.info.initiator,
                    tickets: rawGroup.tickets,
                    privateKeyLoader: this._privateKeyLoader,
                    cardManager: this._cardManager,
                    groupManager: this,
                });
            }
            catch (error) {
                if (error.name === 'GroupTicketNoAccessError') {
                    throw new GroupError(GroupErrorCode.NoAccess, 'Current user has no access to the group ticket');
                }
                throw error;
            }
        });
    }
    addAccess(sessionId, allowedCards) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudTicketStorage = yield this.getCloudTicketStorage();
            const localGroupStorage = yield this.getLocalGroupStorage();
            try {
                yield cloudTicketStorage.addRecipients(sessionId, allowedCards);
                yield localGroupStorage.addParticipants(sessionId, allowedCards.map(card => card.identity));
            }
            catch (error) {
                if (error.name === 'GroupTicketNoAccessError') {
                    throw new GroupError(GroupErrorCode.NoAccess, 'Current user has no access to the group ticket');
                }
                throw error;
            }
        });
    }
    removeAccess(sessionId, forbiddenIdentities) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudTicketStorage = yield this.getCloudTicketStorage();
            yield Promise.all(forbiddenIdentities.map(identity => cloudTicketStorage.removeRecipient(sessionId, identity)));
        });
    }
    delete(sessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudTicketStorage = yield this.getCloudTicketStorage();
            yield cloudTicketStorage.delete(sessionId);
            const localGroupStorage = yield this.getLocalGroupStorage();
            yield localGroupStorage.delete(sessionId);
        });
    }
    reAddAccess(sessionId, allowedCard) {
        return __awaiter(this, void 0, void 0, function* () {
            const cloudTicketStorage = yield this.getCloudTicketStorage();
            try {
                yield cloudTicketStorage.reAddRecipient(sessionId, allowedCard);
            }
            catch (error) {
                if (error.name === 'GroupTicketNoAccessError') {
                    throw new GroupError(GroupErrorCode.NoAccess, 'Current user has no access to the group ticket');
                }
                throw error;
            }
        });
    }
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            const localGroupStorage = yield this.getLocalGroupStorage();
            yield localGroupStorage.reset();
        });
    }
    get selfIdentity() {
        return this._selfIdentity;
    }
    getLocalGroupStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this._privateKeyLoader.loadLocalKeyPair();
            if (keyPair) {
                this._localGroupStorage.setEncryptionKeyPair(keyPair);
            }
            return this._localGroupStorage;
        });
    }
    getCloudTicketStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this._privateKeyLoader.loadLocalKeyPair();
            if (!keyPair) {
                throw new MissingPrivateKeyError();
            }
            const { virgilCrypto, accessTokenProvider, apiUrl } = this._privateKeyLoader.options;
            const keyknoxManager = new KeyknoxManager(new KeyknoxCrypto(virgilCrypto), new KeyknoxClient(accessTokenProvider, apiUrl, undefined, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            new VirgilAgent(process.env.__VIRGIL_PRODUCT_NAME__, process.env.__VIRGIL_PRODUCT_VERSION__)));
            return new CloudGroupTicketStorage(Object.assign({ root: CLOUD_GROUP_SESSIONS_ROOT, identity: this.selfIdentity, keyknoxManager }, keyPair));
        });
    }
}

class VirgilEncryptDownIterator extends AbstractIterator {
    constructor(db, options) {
        super(db);
        this.options = options;
        this.it = db.db.iterator(Object.assign(Object.assign({}, options), { valueAsBuffer: true }));
    }
    _next(callback) {
        this.it.next((err, key, encrypted) => {
            if (err) {
                return callback(err, undefined, undefined);
            }
            if (key === undefined && encrypted === undefined) {
                return callback(undefined, undefined, undefined);
            }
            try {
                const decrypted = this.db.decrypt(encrypted);
                callback(undefined, key, this.options.valueAsBuffer ? decrypted : decrypted.toString('utf8'));
            }
            catch (err) {
                callback(err, undefined, undefined);
            }
        });
    }
    _end(callback) {
        this.it.end(callback);
    }
}
class VirgilEncryptDown extends AbstractLevelDOWN {
    constructor(db, options) {
        super('ignored');
        this.db = db;
        this.crypto = options.virgilCrypto;
        this.keyPair = options.keyPair;
    }
    _open(options, callback) {
        this.db.open(options, callback);
    }
    _close(callback) {
        this.db.close(callback);
    }
    _get(key, options, callback) {
        this.db.get(key, Object.assign(Object.assign({}, options), { asBuffer: true }), (err, encrypted) => {
            if (err) {
                return callback(err, undefined);
            }
            try {
                const decrypted = this.decrypt(encrypted);
                callback(undefined, options.asBuffer ? decrypted : decrypted.toString('utf8'));
            }
            catch (error) {
                callback(error, undefined);
            }
        });
    }
    _put(key, value, options, callback) {
        let encrypted;
        try {
            encrypted = this.encrypt(value);
        }
        catch (err) {
            return setTimeout(() => callback(err));
        }
        this._db.put(key, encrypted, options, callback);
    }
    _del(key, options, callback) {
        this.db.del(key, options, callback);
    }
    _batch(ops, options, callback) {
        let operations;
        try {
            operations = ops.map(op => {
                if (op.type === 'put') {
                    return Object.assign(Object.assign({}, op), { value: this.encrypt(op.value) });
                }
                return op;
            });
        }
        catch (err) {
            return setTimeout(() => callback(err));
        }
        this.db.batch(operations, options, callback);
    }
    _clear(options, callback) {
        this.db.clear(options, callback);
    }
    _iterator(options) {
        return new VirgilEncryptDownIterator(this, options);
    }
    setKeyPair(keyPair) {
        this.keyPair = keyPair;
    }
    encrypt(value) {
        if (!this.keyPair) {
            throw new Error('Cannot encrypt value. Key pair is not set. Call "setKeyPair" first.');
        }
        return this.crypto.signThenEncrypt(value, this.keyPair.privateKey, this.keyPair.publicKey);
    }
    decrypt(encryptedValue) {
        if (!this.keyPair) {
            throw new Error('Cannot decrypt value. Key pair is not set. Call "setKeyPair" first.');
        }
        return this.crypto.decryptThenVerify(encryptedValue, this.keyPair.privateKey, this.keyPair.publicKey);
    }
}

class GroupLocalStorage {
    constructor({ identity, virgilCrypto, leveldown }) {
        this._encryptionLevel = new VirgilEncryptDown(leveldown, { virgilCrypto });
        const rootLevel = levelup(this._encryptionLevel);
        const identityLevel = sub(rootLevel, identity);
        this._db = sub(identityLevel, 'GROUPS', { valueEncoding: 'json' });
    }
    store(rawGroup) {
        return __awaiter(this, void 0, void 0, function* () {
            const lastTicket = rawGroup.tickets[rawGroup.tickets.length - 1];
            if (!lastTicket) {
                throw new Error('Attempted to store group without tickets.');
            }
            const { sessionId } = lastTicket.groupSessionMessage;
            const insertInfo = {
                type: 'put',
                key: sessionId,
                value: rawGroup.info,
            };
            const insertTickets = rawGroup.tickets.map(ticket => ({
                type: 'put',
                key: this.getTicketKey(sessionId, ticket.groupSessionMessage.epochNumber),
                value: ticket,
            }));
            yield this._db.batch([insertInfo, ...insertTickets]);
        });
    }
    retrieve(sessionId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const hasTicketCount = typeof options.ticketCount === 'number';
            const hasEpochNumber = typeof options.epochNumber === 'number';
            if (hasTicketCount === hasEpochNumber) {
                throw new Error('Either "ticketCount" or "epochNumber" option must be provided');
            }
            const [info, tickets] = yield Promise.all([
                this.retrieveGroupInfo(sessionId),
                options.ticketCount
                    ? this.retrieveNLastTickets(sessionId, options.ticketCount)
                    : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        this.retrieveTicketByEpochNumber(sessionId, options.epochNumber),
            ]);
            if (!info || tickets.length === 0)
                return null;
            return { info, tickets };
        });
    }
    delete(sessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const prefix = sessionId;
            yield this._db.clear({
                gt: prefix,
                lte: prefix + '\xff',
            });
        });
    }
    reset() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._db.clear();
        });
    }
    addParticipants(sessionId, participants) {
        return __awaiter(this, void 0, void 0, function* () {
            const [ticket] = yield this.retrieveNLastTickets(sessionId, 1);
            const newTicket = {
                participants: ticket.participants.concat(participants),
                groupSessionMessage: ticket.groupSessionMessage,
            };
            const key = this.getTicketKey(sessionId, ticket.groupSessionMessage.epochNumber);
            // TODO: figure out why 'this._db.put' doesn't work
            // await this._db.put(key, newTicket);
            yield this._db.batch([{ type: 'put', key, value: newTicket }]);
        });
    }
    setEncryptionKeyPair(keyPair) {
        this._encryptionLevel.setKeyPair(keyPair);
    }
    retrieveGroupInfo(sessionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._db.get(sessionId);
            }
            catch (err) {
                if (err.notFound) {
                    return null;
                }
                throw err;
            }
        });
    }
    retrieveNLastTickets(sessionId, ticketCount) {
        return new Promise((resolve, reject) => {
            const tickets = [];
            let error = undefined;
            const prefix = sessionId + '!';
            this._db
                .createReadStream({
                gt: prefix,
                lte: prefix + '\xff',
                reverse: true,
                limit: ticketCount,
            })
                .on('data', data => tickets.unshift(data.value))
                .on('error', err => (error = err))
                .on('end', () => (error ? reject(error) : resolve(tickets)));
        });
    }
    retrieveTicketByEpochNumber(sessionId, epochNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getTicketKey(sessionId, epochNumber);
            try {
                const ticket = yield this._db.get(key);
                return [ticket];
            }
            catch (err) {
                if (err.notFound) {
                    return [];
                }
                throw err;
            }
        });
    }
    getTicketKey(sessionId, epochNumber) {
        // The structure of the ticket key:
        // `<session_id>!<number_of_digits_in_epoch_number_encoded_as_single_char>!<epoch_number>`
        // The reasoning:
        // keys in LevelDB are stored in alphabetical (lexicographic) order,
        // which means that if we just put the epoch number in the key we'll
        // start getting wrong results when reading a stream of tickets because
        // '11' is less than '2', for example.
        // Storing the number of digits in the key allows us to only compare
        // epochs with the same number of digits to each other and have tickets
        // with larger number of digits always be greater than the ones with fewer digits.
        // Since number of digits is also a number and hence susceptible to the
        // same problem, we encode it in base 36 to get a single character so we
        // can handle epoch numbers with up to 35 digits in them (which is more than
        // necessary since epoch number is uint32 in the virgil crypto library)
        const epochNumberStr = String(epochNumber);
        const epochNumberEncodedLength = epochNumberStr.length.toString(36);
        return `${sessionId}!${epochNumberEncodedLength}!${epochNumberStr}`;
    }
}

class AbstractEThree {
    /**
     * @hidden
     */
    constructor(options) {
        this.inProcess = false;
        this.identity = options.identity;
        this.virgilCrypto = options.virgilCrypto;
        this.cardManager = options.cardManager;
        this.accessTokenProvider = options.accessTokenProvider;
        this.keyEntryStorage = options.keyEntryStorage;
        this.keyLoader = options.keyLoader;
        this.groupManager = new GroupManager({
            identity: options.identity,
            privateKeyLoader: options.keyLoader,
            cardManager: options.cardManager,
            groupLocalStorage: new GroupLocalStorage({
                identity: options.identity,
                leveldown: options.groupStorageLeveldown,
                virgilCrypto: options.virgilCrypto,
            }),
        });
        this.keyPairType = options.keyPairType;
    }
    /**
     * Registers current user in Virgil Cloud. Saves private key locally and uploads public key to the cloud.
     */
    register(keyPair) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inProcess) {
                this.throwIllegalInvocationError('register');
            }
            this.inProcess = true;
            try {
                const [cards, privateKey] = yield Promise.all([
                    this.cardManager.searchCards(this.identity),
                    this.keyLoader.loadLocalPrivateKey(),
                ]);
                if (cards.length > 1)
                    throw new MultipleCardsError(this.identity);
                if (cards.length > 0)
                    throw new IdentityAlreadyExistsError();
                if (privateKey)
                    yield this.keyLoader.resetLocalPrivateKey();
                yield this.publishCardThenSavePrivateKeyLocal({ keyPair });
            }
            finally {
                this.inProcess = false;
            }
        });
    }
    /**
     * Generates a new private key and saves locally. Replaces old public key with new one in Cloud.
     * Used in case if old private key is lost.
     */
    rotatePrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inProcess) {
                this.throwIllegalInvocationError('rotatePrivateKey');
            }
            this.inProcess = true;
            try {
                const [cards, privateKey] = yield Promise.all([
                    this.cardManager.searchCards(this.identity),
                    this.keyLoader.loadLocalPrivateKey(),
                ]);
                if (cards.length === 0)
                    throw new RegisterRequiredError();
                if (cards.length > 1)
                    throw new MultipleCardsError(this.identity);
                if (privateKey)
                    throw new PrivateKeyAlreadyExistsError();
                yield this.publishCardThenSavePrivateKeyLocal({ previousCard: cards[0] });
            }
            finally {
                this.inProcess = false;
            }
        });
    }
    /**
     * Downloads private key from Virgil Cloud. Use [[backupPrivateKey]] to upload the key first.
     * @param pwd User password for access to Virgil Keyknox Storage.
     * @param keyName Is a name for the key backup in the cloud.
     */
    restorePrivateKey(pwd, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.keyLoader.restorePrivateKey(pwd, keyName);
            }
            catch (e) {
                if (e instanceof KeyEntryAlreadyExistsError) {
                    throw new PrivateKeyAlreadyExistsError();
                }
                throw e;
            }
        });
    }
    /**
     * Deletes local private key from key storage. Make sure [[backupPrivateKey]] method was called
     * first.
     */
    cleanup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.keyLoader.resetLocalPrivateKey();
            yield this.onPrivateKeyDeleted();
        });
    }
    resetPrivateKeyBackup(pwd) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!pwd) {
                return yield this.keyLoader.resetAll();
            }
            warn(`'resetPrivateKeyBackup(pwd: string)' was deprecated. Please use 'resetPrivateKeyBackup()' instead.`);
            return this.keyLoader.resetPrivateKeyBackup(pwd);
        });
    }
    /**
     * Delete private key saved in Virgil Keyknox Storage.
     * @returns {Promise<void>} - Promise that is resolved if everything went fine.
     */
    resetPrivateKeyBackupWithKeyName(keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.keyLoader.resetPrivateKeyBackupWithKeyName(keyName);
        });
    }
    encrypt(message, recipients) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldReturnString = isString(message);
            const privateKey = yield this.keyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            const publicKeys = this.getPublicKeysForEncryption(privateKey, recipients);
            if (!publicKeys) {
                throw new TypeError('Could not get public keys from the second argument.\n' +
                    'Make sure you pass the resolved value of "EThree.findUsers" or "EThree.lookupPublicKeys" methods ' +
                    'when encrypting for other users, or nothing when encrypting for the current user only.');
            }
            const res = this.virgilCrypto.signThenEncrypt(message, privateKey, publicKeys);
            if (shouldReturnString) {
                return res.toString('base64');
            }
            return res;
        });
    }
    decrypt(message, senderCardOrPublicKey, encryptedAt) {
        return __awaiter(this, void 0, void 0, function* () {
            const shouldReturnString = isString(message);
            const privateKey = yield this.keyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            const senderPublicKey = this.getPublicKeyForVerification(privateKey, senderCardOrPublicKey, encryptedAt);
            if (!senderPublicKey) {
                throw new TypeError('Could not get public key from the second argument.' +
                    'Expected a Virgil Card or a Public Key object. Got ' +
                    typeof senderCardOrPublicKey);
            }
            const res = this.virgilCrypto.decryptThenVerify(message, privateKey, senderPublicKey);
            if (shouldReturnString) {
                return res.toString('utf8');
            }
            return res;
        });
    }
    authEncrypt(arg0, arg1) {
        return __awaiter(this, void 0, void 0, function* () {
            const returnString = isString(arg0);
            const privateKey = yield this.keyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            const publicKeys = this.getPublicKeysForEncryption(privateKey, arg1);
            if (!publicKeys) {
                throw new TypeError('Could not get public keys from the second argument.\n' +
                    'Make sure you pass the resolved value of the "EThree.findUsers" method ' +
                    'when encrypting for other users, or nothing when encrypting for the current user only.');
            }
            const encryptedData = this.virgilCrypto.signAndEncrypt(arg0, privateKey, publicKeys, true);
            if (returnString) {
                return encryptedData.toString('base64');
            }
            return encryptedData;
        });
    }
    authDecrypt(arg0, arg1, arg2) {
        return __awaiter(this, void 0, void 0, function* () {
            const returnString = isString(arg0);
            const privateKey = yield this.keyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            const senderPublicKey = this.getPublicKeyForVerification(privateKey, arg1, arg2);
            if (!senderPublicKey) {
                throw new TypeError('Could not get public key from the second argument.' +
                    'Expected a Virgil Card or a Public Key object. Got ' +
                    typeof arg1);
            }
            const decryptedData = this.virgilCrypto.decryptAndVerify(arg0, privateKey, senderPublicKey);
            if (returnString) {
                return decryptedData.toString('utf8');
            }
            return decryptedData;
        });
    }
    findUsers(identities) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!identities) {
                throw new TypeError('Argument "identities" is required');
            }
            let identitySet;
            if (typeof identities === 'string') {
                identitySet = new Set([identities]);
            }
            else if (isArray(identities)) {
                identitySet = new Set(identities);
            }
            else {
                throw new TypeError(`Expected "identities" to be a string or an array of strings. Got: "${typeof identities}"`);
            }
            if (identitySet.size === 0) {
                throw new TypeError('"identities" array must not be empty');
            }
            const result = Object.create({});
            const identitiesWithMultipleCards = new Set();
            const identityChunks = chunkArray(Array.from(identitySet), MAX_IDENTITIES_TO_SEARCH);
            for (const identityChunk of identityChunks) {
                const cards = yield this.cardManager.searchCards(identityChunk);
                for (const card of cards) {
                    if (result[card.identity]) {
                        identitiesWithMultipleCards.add(card.identity);
                    }
                    result[card.identity] = card;
                }
            }
            const identitiesFound = new Set(Object.keys(result));
            const identitiesNotFound = new Set([...identitySet].filter(i => !identitiesFound.has(i)));
            if (identitiesNotFound.size > 0) {
                throw new UsersNotFoundError([...identitiesNotFound]);
            }
            if (identitiesWithMultipleCards.size > 0) {
                throw new UsersFoundWithMultipleCardsError([...identitiesWithMultipleCards]);
            }
            if (isArray(identities)) {
                return result;
            }
            return result[identities];
        });
    }
    lookupPublicKeys(identities) {
        return __awaiter(this, void 0, void 0, function* () {
            warn('Warning! Method "lookupPublicKeys" has been deprecated, use "findUsers" instead');
            const argument = isArray(identities) ? identities : [identities];
            if (argument.length === 0) {
                throw new Error('Array should be non empty');
            }
            if (hasDuplicates(argument)) {
                throw new Error('Identities in array should be unique');
            }
            const cards = yield this.cardManager.searchCards(argument);
            const result = {};
            const resultWithErrors = {};
            for (const identity of argument) {
                const filteredCards = cards.filter(card => card.identity === identity);
                if (filteredCards.length === 0) {
                    resultWithErrors[identity] = new LookupNotFoundError(identity);
                }
                else if (filteredCards.length > 1) {
                    resultWithErrors[identity] = new MultipleCardsError(identity);
                }
                else {
                    result[identity] = filteredCards[0].publicKey;
                }
            }
            if (getObjectValues(resultWithErrors).length !== 0) {
                throw new LookupError(Object.assign(Object.assign({}, resultWithErrors), result));
            }
            if (Array.isArray(identities)) {
                return result;
            }
            return result[identities];
        });
    }
    /**
     * Changes password for access to current user private key backup.
     * @param oldPwd users old password
     * @param newPwd users new password
     */
    changePassword(oldPwd, newPwd, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.keyLoader.changePassword(oldPwd, newPwd, keyName);
        });
    }
    /**
     * Uploads current user private key to Virgil Keyknox Storage.
     * @param pwd User password for access to Virgil Keyknox Storage
     * @param keyName Is a name that would be used to store backup in the cloud.
     */
    backupPrivateKey(pwd, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKey = yield this.keyLoader.loadLocalPrivateKey();
            if (!privateKey) {
                throw new MissingPrivateKeyError();
            }
            yield this.keyLoader.savePrivateKeyRemote(privateKey, pwd, keyName);
            return;
        });
    }
    /**
     * Checks if current user has private key saved locally.
     */
    hasLocalPrivateKey() {
        return this.keyLoader.hasPrivateKey();
    }
    /**
     * Unregister current user. Revokes public key in Virgil Cloud and deletes local private key.
     *
     * @throws {RegisterRequiredError} If current user is not registered (i.e.
     *                                 there is no Virgil Card for this identity)
     * @throws {MultipleCardsError} If there is more than one Virgil Card for this identity
     */
    unregister() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inProcess) {
                this.throwIllegalInvocationError('unregister');
            }
            this.inProcess = true;
            try {
                const cards = yield this.cardManager.searchCards(this.identity);
                if (cards.length === 0) {
                    throw new RegisterRequiredError();
                }
                for (const card of cards) {
                    yield this.cardManager.revokeCard(card.id);
                }
                yield this.keyLoader.resetLocalPrivateKey();
                yield this.onPrivateKeyDeleted();
            }
            finally {
                this.inProcess = false;
            }
        });
    }
    createGroup(groupId, participants) {
        return __awaiter(this, void 0, void 0, function* () {
            let participantIdentities = new Set();
            let participantCards = [];
            if (isVirgilCard(participants)) {
                participantIdentities = new Set([participants.identity]);
                participantCards = [participants];
            }
            else if (isFindUsersResult(participants)) {
                participantIdentities = new Set(Object.keys(participants));
                participantCards = getObjectValues(participants);
            }
            else if (typeof participants !== 'undefined') {
                throw new TypeError('Expected participants to be the result of "findUsers" method call or to be "typeof undefined"');
            }
            participantIdentities.add(this.identity);
            if (!isValidParticipantCount(participantIdentities.size)) {
                throw new GroupError(GroupErrorCode.InvalidParticipantsCount, `Cannot create group with ${participantIdentities.size} participant(s). Group can have ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[0]} to ${VALID_GROUP_PARTICIPANT_COUNT_RANGE[1]} participants.`);
            }
            const groupSession = this.virgilCrypto.generateGroupSession(groupId);
            const ticket = {
                groupSessionMessage: {
                    epochNumber: groupSession.getCurrentEpochNumber(),
                    sessionId: groupSession.getSessionId(),
                    data: groupSession.export()[0].toString('base64'),
                },
                participants: [...participantIdentities],
            };
            return yield this.groupManager.store(ticket, participantCards);
        });
    }
    loadGroup(groupId, initiatorCard) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = this.virgilCrypto.calculateGroupSessionId(groupId);
            return yield this.groupManager.pull(sessionId, initiatorCard);
        });
    }
    getGroup(groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = this.virgilCrypto.calculateGroupSessionId(groupId);
            return yield this.groupManager.retrieve(sessionId);
        });
    }
    deleteGroup(groupId) {
        return __awaiter(this, void 0, void 0, function* () {
            const sessionId = this.virgilCrypto.calculateGroupSessionId(groupId);
            yield this.groupManager.delete(sessionId);
        });
    }
    /**
     * @hidden
     */
    publishCardThenSavePrivateKeyLocal(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { keyPair, previousCard } = options;
            const myKeyPair = keyPair || this.virgilCrypto.generateKeys(this.keyPairType);
            const card = yield this.cardManager.publishCard({
                privateKey: myKeyPair.privateKey,
                publicKey: myKeyPair.publicKey,
                previousCardId: previousCard ? previousCard.id : undefined,
            });
            yield this.keyLoader.savePrivateKeyLocal(myKeyPair.privateKey);
            return {
                card,
                keyPair: myKeyPair,
            };
        });
    }
    /**
     * @hidden
     */
    isOwnPublicKeyIncluded(ownPublicKey, publicKeys) {
        const selfPublicKey = this.virgilCrypto.exportPublicKey(ownPublicKey).toString('base64');
        const stringKeys = publicKeys.map(key => this.virgilCrypto.exportPublicKey(key).toString('base64'));
        return stringKeys.some(key => key === selfPublicKey);
    }
    throwIllegalInvocationError(method) {
        throw new Error(`Calling ${method} two or more times in a row is not allowed.`);
    }
    /**
     * @hidden
     */
    addOwnPublicKey(privateKey, publicKeys) {
        const ownPublicKey = this.virgilCrypto.extractPublicKey(privateKey);
        if (!this.isOwnPublicKeyIncluded(ownPublicKey, publicKeys)) {
            publicKeys.push(ownPublicKey);
        }
    }
    /**
     * @hidden
     */
    onPrivateKeyDeleted() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.groupManager.cleanup();
        });
    }
    /**
     * @hidden
     */
    getPublicKeysForEncryption(ownPrivateKey, recipients) {
        let publicKeys;
        if (recipients == null) {
            publicKeys = [];
        }
        else if (isVirgilCard(recipients)) {
            publicKeys = [recipients.publicKey];
        }
        else if (isFindUsersResult(recipients)) {
            publicKeys = getObjectValues(recipients).map((card) => card.publicKey);
        }
        else if (this.isPublicKey(recipients)) {
            warn('Warning! Calling `encrypt` with the result of `lookupPublicKeys` method has been deprecated. ' +
                'Please use the result of `findUsers` call instead');
            publicKeys = [recipients];
        }
        else if (isLookupResult(recipients, this.isPublicKey.bind(this))) {
            warn('Warning! Calling `encrypt` with the result of `lookupPublicKeys` method has been deprecated. ' +
                'Please use the result of `findUsers` call instead');
            publicKeys = getObjectValues(recipients).map((publicKey) => publicKey);
        }
        else {
            return null;
        }
        this.addOwnPublicKey(ownPrivateKey, publicKeys);
        return publicKeys;
    }
    /**
     * @hidden
     */
    getPublicKeyForVerification(ownPrivateKey, senderCardOrPublicKey, encryptedAt) {
        if (senderCardOrPublicKey == null) {
            return this.virgilCrypto.extractPublicKey(ownPrivateKey);
        }
        if (isVirgilCard(senderCardOrPublicKey)) {
            return encryptedAt
                ? getCardActiveAtMoment(senderCardOrPublicKey, encryptedAt).publicKey
                : senderCardOrPublicKey.publicKey;
        }
        if (this.isPublicKey(senderCardOrPublicKey)) {
            return senderCardOrPublicKey;
        }
        return null;
    }
}

const BRAIN_KEY_RATE_LIMIT_DELAY = 2000;
const BRAIN_KEY_THROTTLING_ERROR_CODE = 60007;
/**
 * @hidden
 */
function generateBrainPair(pwd, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const pythiaClient = new PythiaClient(options.accessTokenProvider, options.apiUrl, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new VirgilAgent(process.env.__VIRGIL_PRODUCT_NAME__, process.env.__VIRGIL_PRODUCT_VERSION__));
        const brainKey = new BrainKey({
            pythiaClient,
            crypto: options.virgilCrypto,
            brainKeyCrypto: options.pythiaCrypto,
        });
        return yield brainKey.generateKeyPair(pwd).catch((e) => {
            if (typeof e === 'object' && e.code === BRAIN_KEY_THROTTLING_ERROR_CODE) {
                const promise = new Promise((resolve, reject) => {
                    const repeat = () => brainKey
                        .generateKeyPair(pwd)
                        .then(resolve)
                        .catch(reject);
                    setTimeout(repeat, BRAIN_KEY_RATE_LIMIT_DELAY);
                });
                return promise;
            }
            throw e;
        });
    });
}

/**
 * @hidden
 */
class PrivateKeyLoader {
    constructor(identity, options) {
        this.identity = identity;
        this.options = options;
        this.keyknoxClient = new KeyknoxClient(this.options.accessTokenProvider, this.options.apiUrl, undefined, 
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        new VirgilAgent(process.env.__VIRGIL_PRODUCT_NAME__, process.env.__VIRGIL_PRODUCT_VERSION__));
        this.keyknoxCrypto = new KeyknoxCrypto(this.options.virgilCrypto);
        this.cachedPrivateKey = null;
        this.handleResetError = (e) => {
            if (e instanceof CloudEntryDoesntExistError) {
                throw new PrivateKeyNoBackupError();
            }
            throw e;
        };
        this.localStorage = options.keyEntryStorage;
    }
    savePrivateKeyRemote(privateKey, password, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.getStorage(password, isString(keyName));
            return yield storage.storeEntry(this.identity, this.options.virgilCrypto.exportPrivateKey(privateKey).toString('base64'), keyName);
        });
    }
    savePrivateKeyLocal(privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            this.cachedPrivateKey = privateKey;
            return yield this.localStorage.save({
                name: this.identity,
                value: this.options.virgilCrypto.exportPrivateKey(privateKey).toString('base64'),
            });
        });
    }
    loadLocalPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.cachedPrivateKey)
                return this.cachedPrivateKey;
            const privateKeyData = yield this.localStorage.load(this.identity);
            if (!privateKeyData)
                return null;
            return this.importAndCachePrivateKey(privateKeyData.value);
        });
    }
    loadLocalKeyPair() {
        return __awaiter(this, void 0, void 0, function* () {
            const privateKey = yield this.loadLocalPrivateKey();
            if (!privateKey)
                return null;
            const publicKey = this.options.virgilCrypto.extractPublicKey(privateKey);
            return { privateKey, publicKey };
        });
    }
    resetLocalPrivateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.localStorage.remove(this.identity);
            this.cachedPrivateKey = null;
        });
    }
    resetPrivateKeyBackup(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.getStorage(password);
            yield storage.deleteEntry(this.identity).catch(this.handleResetError);
        });
    }
    resetPrivateKeyBackupWithKeyName(keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.keyknoxClient.v2Reset({
                root: 'e3kit',
                path: 'backup',
                key: keyName,
                identity: this.identity,
            });
        });
    }
    resetAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.keyknoxClient.v1Reset();
        });
    }
    restorePrivateKey(password, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.getStorage(password, isString(keyName));
            try {
                const rawKey = !isString(keyName)
                    ? storage.retrieveEntry(this.identity)
                    : yield storage.fetchEntryByKey(this.identity, keyName);
                yield this.localStorage.save({ name: this.identity, value: rawKey.data });
                return this.importAndCachePrivateKey(rawKey.data);
            }
            catch (e) {
                if (e instanceof CloudEntryDoesntExistError) {
                    throw new PrivateKeyNoBackupError();
                }
                throw e;
            }
        });
    }
    changePassword(oldPwd, newPwd, keyName) {
        return __awaiter(this, void 0, void 0, function* () {
            const storage = yield this.getStorage(oldPwd, isString(keyName));
            const keyPair = yield this.generateBrainPair(newPwd);
            if (!isString(keyName)) {
                return yield storage.updateRecipients({
                    newPrivateKey: keyPair.privateKey,
                    newPublicKeys: [keyPair.publicKey],
                });
            }
            else {
                // Change password for key from keyknox v2
                const keyknoxManager = new KeyknoxManager(this.keyknoxCrypto, this.keyknoxClient);
                const oldKeyPair = yield this.generateBrainPair(oldPwd);
                let decryptedKeyknoxValue;
                try {
                    decryptedKeyknoxValue = yield keyknoxManager.v2Pull({
                        root: 'e3kit',
                        path: 'backup',
                        key: keyName,
                        identity: this.identity,
                        privateKey: oldKeyPair.privateKey,
                        publicKeys: [oldKeyPair.publicKey],
                    });
                }
                catch (e) {
                    if (e.name === 'FoundationError' || e.name === 'RNVirgilCryptoError') {
                        throw new WrongKeyknoxPasswordError();
                    }
                    throw e;
                }
                yield keyknoxManager.v2Push({
                    root: 'e3kit',
                    path: 'backup',
                    key: keyName,
                    identities: [this.identity],
                    value: decryptedKeyknoxValue.value,
                    privateKey: keyPair.privateKey,
                    publicKeys: [keyPair.publicKey],
                    keyknoxHash: decryptedKeyknoxValue.keyknoxHash,
                });
            }
        });
    }
    hasPrivateKey() {
        return this.localStorage.exists(this.identity);
    }
    generateBrainPair(pwd) {
        return __awaiter(this, void 0, void 0, function* () {
            return generateBrainPair(pwd, {
                virgilCrypto: this.options.virgilCrypto,
                pythiaCrypto: this.options.brainKeyCrypto,
                accessTokenProvider: this.options.accessTokenProvider,
                apiUrl: this.options.apiUrl,
            });
        });
    }
    getStorage(pwd, skipCloudSync = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.generateBrainPair(pwd);
            const storage = new CloudKeyStorage(new KeyknoxManager(this.keyknoxCrypto, this.keyknoxClient), keyPair.privateKey, keyPair.publicKey);
            if (!skipCloudSync) {
                try {
                    yield storage.retrieveCloudEntries();
                }
                catch (e) {
                    if (e.name === 'FoundationError' || e.name === 'RNVirgilCryptoError') {
                        throw new WrongKeyknoxPasswordError();
                    }
                    throw e;
                }
            }
            return storage;
        });
    }
    importAndCachePrivateKey(rawKeyData) {
        this.cachedPrivateKey = this.options.virgilCrypto.importPrivateKey({
            value: rawKeyData,
            encoding: 'base64',
        });
        return this.cachedPrivateKey;
    }
}

export { AbortError, AbstractEThree, CLOUD_GROUP_SESSIONS_ROOT, DEFAULT_API_URL, DEFAULT_GROUP_STORAGE_NAME, DEFAULT_STORAGE_NAME, GroupError, GroupErrorCode, GroupLocalStorage, IdentityAlreadyExistsError, IntegrityCheckFailedError, LookupError, LookupNotFoundError, MAX_EPOCHS_IN_GROUP_SESSION, MAX_IDENTITIES_TO_SEARCH, MissingPrivateKeyError, MultipleCardsError, PrivateKeyAlreadyExistsError, PrivateKeyLoader, PrivateKeyNoBackupError, RegisterRequiredError, SdkError, UsersFoundWithMultipleCardsError, UsersNotFoundError, VALID_GROUP_PARTICIPANT_COUNT_RANGE, WrongKeyknoxPasswordError };
