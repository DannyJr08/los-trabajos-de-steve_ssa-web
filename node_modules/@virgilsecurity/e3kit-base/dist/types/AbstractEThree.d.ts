import { CardManager } from 'virgil-sdk';
import { AbstractLevelDOWN } from 'abstract-leveldown';
import { PrivateKeyLoader } from './PrivateKeyLoader';
import { Data, ICard, IKeyPair, IPrivateKey, IPublicKey, ICrypto, IAccessTokenProvider, IKeyEntryStorage, NodeBuffer, LookupResult, FindUsersResult } from './types';
import { Group } from './groups/Group';
export declare abstract class AbstractEThree {
    /**
     * Unique identifier of current user. Received from JWT token.
     */
    identity: string;
    /**
     * Instance of implementation of [ICrypto](https://github.com/VirgilSecurity/virgil-crypto-javascript/blob/master/packages/crypto-types/index.d.ts#L23) interface.
     */
    virgilCrypto: ICrypto;
    /**
     * Instance of CardManager. Used to create cards with user public keys.
     */
    cardManager: CardManager;
    /**
     * Instance of IAccessTokenProvider implementation. Using [[getToken]] to receive JWT.
     */
    accessTokenProvider: IAccessTokenProvider;
    /**
     * Instance of IKeyEntryStorage implementation. Used for storing private keys.
     */
    keyEntryStorage: IKeyEntryStorage;
    keyPairType?: any;
    protected keyLoader: PrivateKeyLoader;
    protected inProcess: boolean;
    private groupManager;
    /**
     * @hidden
     */
    constructor(options: {
        identity: string;
        virgilCrypto: ICrypto;
        cardManager: CardManager;
        accessTokenProvider: IAccessTokenProvider;
        keyEntryStorage: IKeyEntryStorage;
        keyLoader: PrivateKeyLoader;
        groupStorageLeveldown: AbstractLevelDOWN;
        keyPairType?: any;
    });
    /**
     * Registers current user in Virgil Cloud. Saves private key locally and uploads public key to the cloud.
     */
    register(keyPair?: IKeyPair): Promise<void>;
    /**
     * Generates a new private key and saves locally. Replaces old public key with new one in Cloud.
     * Used in case if old private key is lost.
     */
    rotatePrivateKey(): Promise<void>;
    /**
     * Downloads private key from Virgil Cloud. Use [[backupPrivateKey]] to upload the key first.
     * @param pwd User password for access to Virgil Keyknox Storage.
     * @param keyName Is a name for the key backup in the cloud.
     */
    restorePrivateKey(pwd: string, keyName?: string): Promise<void>;
    /**
     * Deletes local private key from key storage. Make sure [[backupPrivateKey]] method was called
     * first.
     */
    cleanup(): Promise<void>;
    /**
     * Delete private key saved in Virgil Keyknox Storage.
     * @returns {Promise<void>} - Promise that is resolved if everything went fine.
     */
    resetPrivateKeyBackup(): Promise<void>;
    /**
     * Delete private key saved in Virgil Keyknox Storage.
     *
     * @deprecated and will be removed in next major release.
     *
     * @param {string} pwd - User password for access to Virgil Keyknox Storage.
     * @returns {Promise<void>} - Promise that is resolved if everything went fine.
     */
    resetPrivateKeyBackup(pwd: string): Promise<void>;
    /**
     * Delete private key saved in Virgil Keyknox Storage.
     * @returns {Promise<void>} - Promise that is resolved if everything went fine.
     */
    resetPrivateKeyBackupWithKeyName(keyName: string): Promise<void>;
    /**
     * Encrypts and signs the message for the current user.
     * @param {Data} message - Message to sign and encrypt.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise
     */
    encrypt(message: Data): Promise<NodeBuffer | string>;
    /**
     * Encrypts and signs the message for the current user and a single recipient user.
     * @param {Data} message - Message to sign and encrypt.
     * @param {ICard} card - Virgil Card of the encrypted message recipient.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    encrypt(message: Data, card: ICard): Promise<NodeBuffer | string>;
    /**
     * Encrypts and signs the message for the current user and multiple recipient users.
     * @param {Data} message - Message to sign and encrypt.
     * @param {FindUsersResult} users - Result of the {@link AbstractEThree.findUsers} method.
     * Specifies multiple recipients.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    encrypt(message: Data, users: FindUsersResult): Promise<NodeBuffer | string>;
    /**
     * Encrypts and signs the message for the current user and a single recipient user.
     *
     * Use the overload that accepts `ICard` object instead.
     *
     * @param {Data} message - Message to sign and encrypt.
     * @param {IPublicKey} publicKey - Public key of the encrypted message recipient.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    encrypt(message: Data, publicKey: IPublicKey): Promise<NodeBuffer | string>;
    /**
     * Encrypts and signs the message for the current user and multiple recipient users.
     *
     * @deprecated and will be removed in next major release.
     *
     * Use the overload that accepts `FindUsersResult` object instead.
     *
     *
     * @param {Data} message - Message to sign and encrypt.
     * @param {LookupResult} users - Result of the {@link AbstractEThree.lookupPublicKeys} method.
     * Specifies multiple recipients.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    encrypt(message: Data, publicKeys: LookupResult): Promise<NodeBuffer | string>;
    /**
     * Decrypts and verifies the data encrypted by the current user for the current user.
     * @param {Data} message - Message to decrypt
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    decrypt(message: Data): Promise<NodeBuffer | string>;
    /**
     * Decrypts and verifies the data encrypted by the user identified by `senderCard` for the
     * current user.
     * @param {Data} message - Message to decrypt
     * @param {ICard} senderCard - Virgil Card of the user who encrypted and signed the message.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    decrypt(message: Data, senderCard: ICard): Promise<NodeBuffer | string>;
    /**
     * Decrypts and verifies the data encrypted by the user identified by `senderCard` for the
     * current user. If the sender had ever rotated their keys (e.g. by using the
     * {@link EThree.rotatePrivateKey} method), then the `encryptedAt` date is used to find the
     * public key that was current at the time of encryption.
     * @param {Data} message - Message to decrypt
     * @param {ICard} senderCard - Virgil Card of the user who encrypted and signed the message.
     * @param {Date} encryptedAt - The date the message was encrypted on.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    decrypt(message: Data, senderCard: ICard, encryptedAt: Date): Promise<NodeBuffer | string>;
    /**
     * Decrypts and verifies the data encrypted by the user identified by `senderPublicKey` for the
     * current user.
     *
     * @deprecated and will be removed in next major release.
     *
     * Use the overload that accepts Virgil Card object instead.
     *
     * @param {Data} message - Message to decrypt
     * @param {IPublicKey} senderPublicKey - Public key of the user who encrypted and signed the message.
     * @returns {Promise<NodeBuffer | string>} Promise that is that resolves to a string if `message`
     * was a string and `Buffer` otherwise.
     */
    decrypt(message: Data, senderPublicKey: IPublicKey): Promise<NodeBuffer | string>;
    authEncrypt(message: Data): Promise<NodeBuffer | string>;
    authEncrypt(message: Data, publicKey: IPublicKey): Promise<NodeBuffer | string>;
    authEncrypt(message: Data, card: ICard): Promise<NodeBuffer | string>;
    authEncrypt(message: Data, users: FindUsersResult): Promise<NodeBuffer | string>;
    authDecrypt(message: Data): Promise<NodeBuffer | string>;
    authDecrypt(message: Data, publicKey: IPublicKey): Promise<NodeBuffer | string>;
    authDecrypt(message: Data, card: ICard, encryptedAt?: Date): Promise<NodeBuffer | string>;
    /**
     * Finds Virgil Card for user identity registered on Virgil Cloud.
     *
     * @param {string} - Identity of the user to find the Virgil Card of.
     *
     * @returns {Promise<ICard>} - Promise that resolves to the Virgil Card object.
     *
     * @throws {UsersNotFoundError} in case the Virgil Card wasn't found for the
     * given identity.
     *
     * @throws {UsersFoundWithMultipleCardsError} in case the given user has more than
     * one Virgil Card, which is not allowed with E3kit.
     */
    findUsers(identity: string): Promise<ICard>;
    /**
     * Finds Virgil Cards for user identities registered on Virgil Cloud.
     *
     * @param {string[]} - A list of user identities to find the Virgil Cards of.
     *
     * @returns {Promise<FindUsersResult>} - Promise that resolves to a hash with
     * identities as keys and Virgil Card objects as values.
     *
     * @throws {UsersNotFoundError} in case the Virgil Card wasn't found for any one of the
     * given identities.
     *
     * @throws {UsersFoundWithMultipleCardsError} in case any one of the given users have
     * more than one Virgil Card, which is not allowed with E3kit.
     */
    findUsers(identities: string[]): Promise<FindUsersResult>;
    /**
     * Finds public key for user identity registered on Virgil Cloud.
     *
     * @deprecated and will be removed in next major release.
     *
     * Use the {@link EThree.findUsers} instead, which returns Virgil Cards instead
     * of just the public keys. You can get a public key out of the Virgil Card object
     * via the `publicKey` property.
     *
     * @param {string} - Identity of the user to lookup the public key of.
     *
     * @returns {Promise<IPublicKey>} - Promise that resolves to a public key object.
     */
    lookupPublicKeys(identity: string): Promise<IPublicKey>;
    /**
     * Finds public keys for user identities registered on Virgil Cloud.
     *
     * @deprecated and will be removed in next major release.
     *
     * Use the {@link EThree.findUsers} instead, which returns Virgil Cards instead
     * of just the public keys. You can get a public key out of the Virgil Card object
     * via the `publicKey` property.
     *
     * @param {string[]} - A list of user identities to lookup the public keys of.
     *
     * @returns {Promise<LookupResult | IPublicKey>} - Promise that resolves to a hash with
     * identities as keys and public key objects as values.
     */
    lookupPublicKeys(identities: string[]): Promise<LookupResult>;
    /**
     * Changes password for access to current user private key backup.
     * @param oldPwd users old password
     * @param newPwd users new password
     */
    changePassword(oldPwd: string, newPwd: string, keyName?: string): Promise<void>;
    /**
     * Uploads current user private key to Virgil Keyknox Storage.
     * @param pwd User password for access to Virgil Keyknox Storage
     * @param keyName Is a name that would be used to store backup in the cloud.
     */
    backupPrivateKey(pwd: string, keyName?: string): Promise<void>;
    /**
     * Checks if current user has private key saved locally.
     */
    hasLocalPrivateKey(): Promise<boolean>;
    /**
     * Unregister current user. Revokes public key in Virgil Cloud and deletes local private key.
     *
     * @throws {RegisterRequiredError} If current user is not registered (i.e.
     *                                 there is no Virgil Card for this identity)
     * @throws {MultipleCardsError} If there is more than one Virgil Card for this identity
     */
    unregister(): Promise<void>;
    createGroup(groupId: Data): Promise<Group>;
    createGroup(groupId: Data, participant: ICard): Promise<Group>;
    createGroup(groupId: Data, participants: FindUsersResult): Promise<Group>;
    loadGroup(groupId: Data, initiatorCard: ICard): Promise<Group>;
    getGroup(groupId: Data): Promise<Group | null>;
    deleteGroup(groupId: Data): Promise<void>;
    /**
     * @hidden
     */
    private publishCardThenSavePrivateKeyLocal;
    /**
     * @hidden
     */
    private isOwnPublicKeyIncluded;
    private throwIllegalInvocationError;
    /**
     * @hidden
     */
    private addOwnPublicKey;
    /**
     * @hidden
     */
    private onPrivateKeyDeleted;
    /**
     * @hidden
     */
    protected getPublicKeysForEncryption(ownPrivateKey: IPrivateKey, recipients?: ICard | FindUsersResult | IPublicKey | LookupResult): IPublicKey[] | null;
    /**
     * @hidden
     */
    protected getPublicKeyForVerification(ownPrivateKey: IPrivateKey, senderCardOrPublicKey?: ICard | IPublicKey, encryptedAt?: Date | number): IPublicKey | null;
    /**
     * @hidden
     */
    protected abstract isPublicKey(publicKey: any): boolean;
}
