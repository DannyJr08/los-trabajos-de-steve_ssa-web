/// <reference types="node" />
import { AbstractEThree } from '@virgilsecurity/e3kit-base';
import { Data, ICard, IPublicKey, FoundationLibraryOptions, EThreeInitializeOptions, EThreeCtorOptions, EncryptFileOptions, DecryptFileOptions, LookupResult, FindUsersResult, AuthDecryptFileOptions, EncryptSharedFileResult, EncryptSharedFileOptions, DecryptSharedFileOptions } from './types';
export declare class EThree extends AbstractEThree {
    /**
     * @hidden
     * @param identity - Identity of the current user.
     */
    constructor(identity: string, options: EThreeCtorOptions);
    /**
     * Initialize a new instance of EThree which tied to specific user.
     * @param getToken - Function that receive JWT.
     */
    static initialize(getToken: () => Promise<string>, options?: EThreeInitializeOptions): Promise<EThree>;
    static derivePasswords(password: Data, options?: FoundationLibraryOptions): Promise<{
        loginPassword: Buffer;
        backupPassword: Buffer;
    }>;
    /**
     * Signs and encrypts File or Blob.
     * If there is no recipient and the message is encrypted for the current user, omit the
     * public key parameter. You can define chunk size and a callback, that will be invoked on each chunk.
     *
     * The file will be read twice during this method execution:
     * 1. To calculate the signature of the plaintext file.
     * 2. To encrypt the file with encoded signature.
     */
    /**
     * @deprecated and will be removed in next major release.
     */
    encryptFile(file: File | Blob, recipients?: ICard | FindUsersResult, options?: EncryptFileOptions): Promise<File | Blob>;
    encryptFile(file: File | Blob, recipients?: IPublicKey | LookupResult, options?: EncryptFileOptions): Promise<File | Blob>;
    /**
     * @deprecated and will be removed in next major release.
     * Decrypts and verifies integrity of File or Blob for recipient public key. If there is no recipient
     * and the message is encrypted for the current user, omit the public key parameter. You can define
     * chunk size and a callback, that will be invoked on each chunk.
     *
     * The file will be read twice during this method execution:
     * 1. To decrypt encrypted file.
     * 2. To verify the validity of the signature over the decrypted file for the public key.
     */
    decryptFile(file: File | Blob, senderCardOrPublicKey?: ICard | IPublicKey, options?: DecryptFileOptions): Promise<File | Blob>;
    /**
     * Signs and encrypts File or Blob.
     * If there is no recipient and the message is encrypted for the current user, omit the
     * public key parameter. You can define chunk size and a callback, that will be invoked on each chunk.
     */
    authEncryptFile(file: File | Blob, recipients?: ICard | FindUsersResult, options?: EncryptFileOptions): Promise<File | Blob>;
    authEncryptFile(file: File | Blob, recipients?: IPublicKey | LookupResult, options?: EncryptFileOptions): Promise<File | Blob>;
    /**
     * Decrypts and verifies integrity of File or Blob for recipient public key. If there is no recipient
     * and the message is encrypted for the current user, omit the public key parameter. You can define
     * chunk size and a callback, that will be invoked on each chunk.
     *
     * The file will be read twice during this method execution:
     * 1. To decrypt encrypted file.
     * 2. To verify the validity of the signature over the decrypted file for the public key.
     */
    authDecryptFile(file: File | Blob, senderCardOrPublicKey?: ICard | IPublicKey, options?: AuthDecryptFileOptions): Promise<File | Blob>;
    /**
     * Encrypts file with `fileKey` which can be shared among other users.
     * You can define chunk size and a callback, that will be invoked on each chunk.
     */
    encryptSharedFile(file: File | Blob, options?: EncryptSharedFileOptions): Promise<EncryptSharedFileResult>;
    /**
     * Decrypts File or Blob with `fileKey` and verifies integrity with `senderCardOrPublicKey`. If there is no recipient
     * and the message is encrypted for the current user, omit the `senderCardOrPublicKey` parameter. You can define
     * chunk size and a callback, that will be invoked on each chunk.
     *
     */
    decryptSharedFile(file: File | Blob, fileKey: Data, senderCardOrPublicKey?: ICard | IPublicKey, options?: DecryptSharedFileOptions): Promise<File | Blob>;
    /**
     * @hidden
     */
    private static getFoundationLibraryOptions;
    /**
     * @hidden
     */
    private static getPythiaLibraryOptions;
    /**
     * @hidden
     */
    private static prepareConstructorParams;
    /**
     * @hidden
     */
    protected isPublicKey(publicKey: any): boolean;
    /**
     * @hidden
     */
    private toData;
}
