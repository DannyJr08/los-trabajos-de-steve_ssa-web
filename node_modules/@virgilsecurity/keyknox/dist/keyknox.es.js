import e from"axios";import{VirgilAgent as t}from"virgil-sdk";import i from"base-64";
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function r(e,t){var i={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(i[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var n=0;for(r=Object.getOwnPropertySymbols(e);n<r.length;n++)t.indexOf(r[n])<0&&(i[r[n]]=e[r[n]])}return i}function n(e,t,i,r){return new(i||(i=Promise))((function(n,s){function o(e){try{y(r.next(e))}catch(e){s(e)}}function a(e){try{y(r.throw(e))}catch(e){s(e)}}function y(e){e.done?n(e.value):new i((function(t){t(e.value)})).then(o,a)}y((r=r.apply(e,t||[])).next())}))}class s extends Error{constructor(e,t="KeyknoxError",i=s){super(e),Object.setPrototypeOf(this,i.prototype),this.name=t}}class o extends s{constructor(e,t,i){super(e,"KeyknoxClientError",o),this.status=t,this.code=i}}class a extends s{constructor(){super("CloudKeyStorage is out of sync","CloudKeyStorageOutOfSyncError",a)}}class y extends s{constructor(e){super(`Cloud entry '${e}' already exists`,"CloudEntryExistsError",y),this.cloudEntryName=e}}class c extends s{constructor(e){super(`Cloud entry '${e}' doesn't exist`,"CloudEntryDoesntExistError",c),this.cloudEntryName=e}}class d extends s{constructor(e){super(`Key entry '${e}' already exists`,"KeyEntryExistsError",d),this.keyEntryName=e}}class h extends s{constructor(e){super(`Key entry '${e}' doesn't exist`,"KeyEntryDoesntExistError",h),this.keyEntryName=e}}class u extends s{constructor(){super("GroupSessionMessageInfo already exist","GroupTicketAlreadyExistsError",u)}}class l extends s{constructor(){super("Group ticket doesn't exist","GroupTicketDoesntExistError",l)}}class v extends s{constructor(){super("Current user has no access to the group ticket","GroupTicketNoAccessError",v)}}class p{constructor(i,r,n,s){this.accessTokenProvider=i,this.axios=n||e.create({baseURL:r||p.API_URL}),this.virgilAgent=s||new t("keyknox","1.0.3"),this.axios.interceptors.response.use(void 0,p.responseErrorHandler)}v1Push(e,t,i){return n(this,void 0,void 0,(function*(){const r={meta:e,value:t},n=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"put"}),s={headers:p.getHeaders({accessToken:n,keyknoxHash:i,virgilAgent:this.virgilAgent})},o=yield this.axios.put("/keyknox/v1",r,s);return p.getKeyknoxValueV1(o)}))}v1Pull(){return n(this,void 0,void 0,(function*(){const e=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),t={headers:p.getHeaders({accessToken:e,virgilAgent:this.virgilAgent})},i=yield this.axios.get("/keyknox/v1",t);return p.getKeyknoxValueV1(i)}))}v1Reset(){return n(this,void 0,void 0,(function*(){const e=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"delete"}),t={headers:p.getHeaders({accessToken:e,virgilAgent:this.virgilAgent})},i=yield this.axios.post("/keyknox/v1/reset",void 0,t);return p.getKeyknoxValueV1(i)}))}v2Push(e){return n(this,void 0,void 0,(function*(){const{root:t,path:i,key:r,identities:n,meta:s,value:o,keyknoxHash:a}=e,y={root:t,path:i,key:r,identities:n,meta:s,value:o},c=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"put"}),d={headers:p.getHeaders({accessToken:c,keyknoxHash:a,virgilAgent:this.virgilAgent})},h=yield this.axios.post("/keyknox/v2/push",y,d);return p.getKeyknoxValueV2(h)}))}v2Pull(e){return n(this,void 0,void 0,(function*(){const{root:t,path:i,key:r,identity:n}=e,s={root:t,path:i,key:r,identity:n},o=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),a={headers:p.getHeaders({accessToken:o,virgilAgent:this.virgilAgent})},y=yield this.axios.post("/keyknox/v2/pull",s,a);return p.getKeyknoxValueV2(y)}))}v2GetKeys(e){return n(this,void 0,void 0,(function*(){const{root:t,path:i,identity:r}=e,n={root:t,path:i,identity:r},s=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"get"}),o={headers:p.getHeaders({accessToken:s,virgilAgent:this.virgilAgent})};return(yield this.axios.post("/keyknox/v2/keys",n,o)).data}))}v2Reset(e){return n(this,void 0,void 0,(function*(){const{root:t,path:i,key:r,identity:n}=e,s={root:t,path:i,key:r,identity:n},o=yield this.accessTokenProvider.getToken({service:"keyknox",operation:"delete"}),a={headers:p.getHeaders({accessToken:o,virgilAgent:this.virgilAgent})},y=yield this.axios.post("/keyknox/v2/reset",s,a);return p.getKeyknoxValueV2(y)}))}static getKeyknoxValueV1(e){const{data:t,headers:i}=e;return{meta:t.meta,value:t.value,version:t.version,keyknoxHash:i["virgil-keyknox-hash"]}}static getKeyknoxValueV2(e){const{data:t,headers:i}=e;return{owner:t.owner,root:t.root,path:t.path,key:t.key,identities:t.identities,meta:t.meta,value:t.value,keyknoxHash:i["virgil-keyknox-hash"]}}static getHeaders(e){const{virgilAgent:t,accessToken:i,keyknoxHash:r}=e,n={"Virgil-Agent":t.value};return i&&(n.Authorization="Virgil "+i.toString()),r&&(n["Virgil-Keyknox-Previous-Hash"]=r),n}static responseErrorHandler(e){const{response:t}=e;if(t){const{data:i}=t;return i&&i.code&&i.message?Promise.reject(new o(i.message,t.status,i.code)):Promise.reject(new o(e.message,t.status))}return Promise.reject(new o(e.message))}}p.API_URL="https://api.virgilsecurity.com";class k{constructor(e){this.crypto=e}decrypt(e,t,i,r){if(!t||!e){if(t||e)throw new TypeError("'metadata' or 'encryptedData' is empty");return t}return this.crypto.decryptThenVerifyDetached({value:t,encoding:"base64"},{value:e,encoding:"base64"},i,r).toString("base64")}encrypt(e,t,i){const{metadata:r,encryptedData:n}=this.crypto.signThenEncryptDetached({value:e,encoding:"base64"},t,i);return{metadata:r.toString("base64"),encryptedData:n.toString("base64")}}}class g{constructor(e,t){this.myKeyknoxCrypto=e,this.keyknoxClient=t}get keyknoxCrypto(){return this.myKeyknoxCrypto}static create(e,t){const i=new p(e);return new g(t,i)}v1Push(e,t,i,r){return n(this,void 0,void 0,(function*(){const{metadata:n,encryptedData:s}=this.myKeyknoxCrypto.encrypt(e,t,i),o=yield this.keyknoxClient.v1Push(n,s,r);return this.v1Decrypt(o,t,i)}))}v1Pull(e,t){return n(this,void 0,void 0,(function*(){const i=yield this.keyknoxClient.v1Pull();return this.v1Decrypt(i,e,t)}))}v1Reset(){return n(this,void 0,void 0,(function*(){return this.keyknoxClient.v1Reset()}))}v1Update(e){return n(this,void 0,void 0,(function*(){const{value:t,privateKey:i,publicKeys:r,keyknoxHash:n,newPrivateKey:s,newPublicKeys:o}=e;if(!s&&!o)return this.v1Push(t,i,r,n);const a=yield this.v1Pull(i,r),y=s||i,c=o||r,{metadata:d,encryptedData:h}=this.myKeyknoxCrypto.encrypt(a.value,y,c),u=yield this.keyknoxClient.v1Push(d,h,a.keyknoxHash);return this.v1Decrypt(u,y,c)}))}v1UpdateRecipients(e){return n(this,void 0,void 0,(function*(){const{privateKey:t,publicKeys:i,newPrivateKey:r,newPublicKeys:n}=e,s=yield this.v1Pull(t,i);if(!s.meta&&!s.value)return s;const o=r||t,a=n||i,{metadata:y,encryptedData:c}=this.myKeyknoxCrypto.encrypt(s.value,o,a),d=yield this.keyknoxClient.v1Push(y,c,s.keyknoxHash);return this.v1Decrypt(d,o,a)}))}v2Push(e){return n(this,void 0,void 0,(function*(){const{value:t,privateKey:i,publicKeys:n}=e,s=r(e,["value","privateKey","publicKeys"]),{metadata:o,encryptedData:a}=this.encrypt(t,i,n),y=yield this.keyknoxClient.v2Push(Object.assign(Object.assign({},s),{value:a,meta:o}));return this.v2Decrypt(y,i,n)}))}v2Pull(e){return n(this,void 0,void 0,(function*(){const{privateKey:t,publicKeys:i}=e,n=r(e,["privateKey","publicKeys"]),s=yield this.keyknoxClient.v2Pull(n);return this.v2Decrypt(s,t,i)}))}v2GetKeys(e){return n(this,void 0,void 0,(function*(){return this.keyknoxClient.v2GetKeys(e)}))}v2Reset(e){return n(this,void 0,void 0,(function*(){return this.keyknoxClient.v2Reset(e)}))}v1Decrypt(e,t,i){const{meta:n,value:s}=e,o=r(e,["meta","value"]),a=this.myKeyknoxCrypto.decrypt(n,s,t,i);return Object.assign(Object.assign({},o),{meta:n,value:a})}v2Decrypt(e,t,i){const{meta:n,value:s}=e,o=r(e,["meta","value"]),a=this.myKeyknoxCrypto.decrypt(n,s,t,i);return Object.assign(Object.assign({},o),{meta:n,value:a})}encrypt(e,t,i){return this.myKeyknoxCrypto.encrypt(e,t,i)}}class m{constructor(e){const{keyknoxManager:t,identity:i,privateKey:r,publicKey:n,root:s}=e;this.keyknoxManager=t,this.identity=i,this.privateKey=r,this.publicKey=n,this.root=s||m.DEFAULT_ROOT}static create(e){const{accessTokenProvider:t,identity:i,privateKey:r,publicKey:n,virgilCrypto:s,root:o}=e,a=g.create(t,new k(s));return new m({keyknoxManager:a,identity:i,privateKey:r,publicKey:n,root:o})}store(e,t){return n(this,void 0,void 0,(function*(){const{epochNumber:i,sessionId:r,data:n}=e;let s=[this.identity],a=[this.publicKey];if(t){const e=Array.isArray(t)?t:[t];s=s.concat(e.map(e=>e.identity)),a=a.concat(e.map(e=>e.publicKey))}try{yield this.keyknoxManager.v2Push({identities:s,publicKeys:a,privateKey:this.privateKey,root:this.root,path:r,key:i.toString(),value:n})}catch(e){if(e instanceof o&&50010===e.code)throw new u;throw e}}))}retrieve(e,t,i){return n(this,void 0,void 0,(function*(){let r=this.identity,n=this.publicKey;if(t&&i)r=t,n=i;else if(Boolean(t)!==Boolean(i))throw new Error("You need to provide both 'identity' and 'publicKey'");const s=yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:r});if(!s.length)throw new l;const o=s.map(t=>this.keyknoxManager.v2Pull({root:this.root,path:e,key:t,identity:r,privateKey:this.privateKey,publicKeys:n}));try{const e=yield Promise.all(o);return e.map(({key:e,path:t,identities:i,value:r})=>({identities:i,groupSessionMessageInfo:{sessionId:t,epochNumber:Number(e),data:r}}))}catch(e){throw m.throwIfRecipientIsNotFound(e),e}}))}addRecipients(e,t){return n(this,void 0,void 0,(function*(){const i=(yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:this.identity})).map(i=>n(this,void 0,void 0,(function*(){const r=yield this.keyknoxManager.v2Pull({root:this.root,path:e,key:i,identity:this.identity,privateKey:this.privateKey,publicKeys:this.publicKey});yield this.keyknoxManager.v2Push(Object.assign(Object.assign({},r),{identities:t.map(e=>e.identity),publicKeys:[this.publicKey,...t.map(e=>e.publicKey)],privateKey:this.privateKey}))})));try{yield Promise.all(i)}catch(e){throw m.throwIfRecipientIsNotFound(e),e}}))}addRecipient(e,t){return n(this,void 0,void 0,(function*(){return this.addRecipients(e,[t])}))}reAddRecipient(e,t){return n(this,void 0,void 0,(function*(){const i=(yield this.keyknoxManager.v2GetKeys({root:this.root,path:e,identity:this.identity})).map(i=>n(this,void 0,void 0,(function*(){const r=yield this.keyknoxManager.v2Pull({root:this.root,path:e,key:i,identity:this.identity,privateKey:this.privateKey,publicKeys:this.publicKey});yield this.removeRecipient(e,t.identity,Number(i)),yield this.keyknoxManager.v2Push({root:this.root,path:e,key:i,identities:[t.identity],value:r.value,privateKey:this.privateKey,publicKeys:[this.publicKey,t.publicKey],keyknoxHash:r.keyknoxHash})})));try{yield Promise.all(i)}catch(e){throw m.throwIfRecipientIsNotFound(e),e}}))}removeRecipient(e,t,i){return n(this,void 0,void 0,(function*(){yield this.keyknoxManager.v2Reset({identity:t,root:this.root,path:e,key:"number"==typeof i?i.toString():void 0})}))}delete(e){return n(this,void 0,void 0,(function*(){return this.keyknoxManager.v2Reset({root:this.root,path:e})}))}static throwIfRecipientIsNotFound(e){if("FoundationError"===e.name&&/recipient defined with id is not found/gi.test(e.message))throw new v}}function K(e){const t={};return e.forEach((e,i)=>{t[i]={data:e.data,meta:e.meta,creation_date:Number(e.creationDate),name:e.name,modification_date:Number(e.modificationDate)},null===t[i].meta&&delete t[i].meta}),i.encode(JSON.stringify(t))}function x(e){const t=i.decode(e);if(!t.length)return new Map;const r=JSON.parse(t);return Object.keys(r).reduce((e,t)=>{const i=r[t];return e.set(t,{name:i.name,data:i.data,creationDate:new Date(i.creation_date),modificationDate:new Date(i.modification_date),meta:void 0===i.meta?null:i.meta}),e},new Map)}m.DEFAULT_ROOT="group-sessions";class f{constructor(e,t,i){this.cache=new Map,this.syncWasCalled=!1,this.keyknoxManager=e,this.privateKey=t,this.publicKeys=i}static create(e){const{accessTokenProvider:t,privateKey:i,publicKeys:r,virgilCrypto:n}=e,s=g.create(t,new k(n));return new f(s,i,r)}storeEntries(e){return n(this,void 0,void 0,(function*(){return this.throwUnlessSyncWasCalled(),e.forEach(e=>{this.throwIfCloudEntryExists(e.name),this.cache.set(e.name,f.createCloudEntry(e))}),yield this.pushCacheEntries(),e.map(e=>this.cache.get(e.name))}))}storeEntry(e,t,i){return n(this,void 0,void 0,(function*(){if("string"==typeof i){const r=i,n=yield this.keyknoxManager.v2Pull({root:"e3kit",path:"backup",key:r,identity:e,privateKey:this.privateKey,publicKeys:this.publicKeys}),s=f.createCloudEntry({name:r,data:t});return x((yield this.keyknoxManager.v2Push({root:"e3kit",path:"backup",key:r,identities:[e],value:K(new Map([[r,s]])),privateKey:this.privateKey,publicKeys:this.publicKeys,keyknoxHash:n.keyknoxHash})).value).values().next().value}{const[r]=yield this.storeEntries([{name:e,data:t,meta:i}]);return r}}))}updateEntry(e,t,i){return n(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled(),this.throwUnlessCloudEntryExists(e);const r=f.createCloudEntry({name:e,data:t,meta:i},this.cache.get(e).creationDate);return this.cache.set(e,r),yield this.pushCacheEntries(),r}))}retrieveEntry(e){return this.throwUnlessSyncWasCalled(),this.throwUnlessCloudEntryExists(e),this.cache.get(e)}fetchEntryByKey(e,t){return n(this,void 0,void 0,(function*(){return x((yield this.keyknoxManager.v2Pull({root:"e3kit",path:"backup",key:t,identity:e,privateKey:this.privateKey,publicKeys:this.publicKeys})).value).values().next().value}))}retrieveAllEntries(){return this.throwUnlessSyncWasCalled(),Array.from(this.cache.values())}existsEntry(e){return this.throwUnlessSyncWasCalled(),this.cache.has(e)}deleteEntry(e){return n(this,void 0,void 0,(function*(){yield this.deleteEntries([e])}))}deleteEntries(e){return n(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled(),e.forEach(e=>{this.throwUnlessCloudEntryExists(e),this.cache.delete(e)}),yield this.pushCacheEntries()}))}deleteAllEntries(){return n(this,void 0,void 0,(function*(){this.cache.clear(),this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Reset()}))}updateRecipients(e){return n(this,void 0,void 0,(function*(){this.throwUnlessSyncWasCalled();const{newPrivateKey:t,newPublicKeys:i}=e;this.decryptedKeyknoxValue=yield this.keyknoxManager.v1UpdateRecipients({newPrivateKey:t,newPublicKeys:i,privateKey:this.privateKey,publicKeys:this.publicKeys}),this.privateKey=t||this.privateKey,this.publicKeys=i||this.publicKeys,this.cache=x(this.decryptedKeyknoxValue.value)}))}retrieveCloudEntries(){return n(this,void 0,void 0,(function*(){this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Pull(this.privateKey,this.publicKeys),this.cache=x(this.decryptedKeyknoxValue.value),this.syncWasCalled=!0}))}throwUnlessSyncWasCalled(){if(!this.syncWasCalled)throw new a}throwUnlessCloudEntryExists(e){if(!this.cache.has(e))throw new c(e)}throwIfCloudEntryExists(e){if(this.cache.has(e))throw new y(e)}pushCacheEntries(){return n(this,void 0,void 0,(function*(){const e=K(this.cache);this.decryptedKeyknoxValue=yield this.keyknoxManager.v1Push(e,this.privateKey,this.publicKeys,this.decryptedKeyknoxValue.keyknoxHash),this.cache=x(this.decryptedKeyknoxValue.value)}))}static createCloudEntry(e,t){const i=new Date;return{name:e.name,data:e.data,meta:void 0===e.meta?null:e.meta,creationDate:t||i,modificationDate:i}}}class E{constructor(e,t){this.formatKeyEntry=e=>Object.assign(Object.assign({},e),{name:e.name.replace(this.prefix,"")}),this.prefix=`_VIRGIL_IDENTITY=${e}.`,this.prefixRegExp=new RegExp("^"+this.prefix),this.keyEntryStorage=t}save(e){return n(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.save(Object.assign(Object.assign({},e),{name:this.getKeyEntryName(e.name)}));return this.formatKeyEntry(t)}))}load(e){return n(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.load(this.getKeyEntryName(e));return null===t?null:this.formatKeyEntry(t)}))}exists(e){return this.keyEntryStorage.exists(this.getKeyEntryName(e))}remove(e){return this.keyEntryStorage.remove(this.getKeyEntryName(e))}list(){return n(this,void 0,void 0,(function*(){return(yield this.getAllKeyEntries()).map(this.formatKeyEntry)}))}update(e){return n(this,void 0,void 0,(function*(){const t=yield this.keyEntryStorage.update(Object.assign(Object.assign({},e),{name:this.getKeyEntryName(e.name)}));return this.formatKeyEntry(t)}))}clear(){return n(this,void 0,void 0,(function*(){const e=yield this.getAllKeyEntries();for(const t of e)yield this.keyEntryStorage.remove(t.name)}))}getKeyEntryName(e){return`${this.prefix}${e}`}getAllKeyEntries(){return n(this,void 0,void 0,(function*(){return(yield this.keyEntryStorage.list()).filter(e=>this.prefixRegExp.test(e.name))}))}}function w(e){return{name:e.name,value:e.data,meta:Object.assign(Object.assign({},e.meta),{k_cda:e.creationDate.toISOString(),k_mda:e.modificationDate.toISOString()})}}class b{constructor(e,t,i){this.cloudKeyStorage=t,this.keyEntryStorageWrapper=new E(e,i)}static create(e){const{virgilCrypto:t,identity:i,accessTokenProvider:r,privateKey:n,publicKeys:s}=e,o=f.create({accessTokenProvider:r,privateKey:n,publicKeys:s,virgilCrypto:t});return new b(i,o,e.keyEntryStorage)}storeEntries(e){return n(this,void 0,void 0,(function*(){const t=e.map(e=>this.throwIfKeyEntryExists(e.name));yield Promise.all(t);const i=(yield this.cloudKeyStorage.storeEntries(e)).map(e=>n(this,void 0,void 0,(function*(){const t=w(e);return this.keyEntryStorageWrapper.save(t)})));return Promise.all(i)}))}storeEntry(e,t,i){return n(this,void 0,void 0,(function*(){const[r]=yield this.storeEntries([{name:e,data:t,meta:i}]);return r}))}updateEntry(e,t,i){return n(this,void 0,void 0,(function*(){yield this.throwUnlessKeyEntryExists(e);const r=w(yield this.cloudKeyStorage.updateEntry(e,t,i));yield this.keyEntryStorageWrapper.update(r)}))}retrieveEntry(e){return n(this,void 0,void 0,(function*(){return yield this.throwUnlessKeyEntryExists(e),this.keyEntryStorageWrapper.load(e)}))}retrieveAllEntries(){return this.keyEntryStorageWrapper.list()}existsEntry(e){return this.keyEntryStorageWrapper.exists(e)}deleteEntry(e){return this.deleteEntries([e])}deleteEntries(e){return n(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.deleteEntries(e);const t=e.map(e=>this.keyEntryStorageWrapper.remove(e));yield Promise.all(t)}))}deleteAllEntries(){return n(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.deleteAllEntries(),yield this.keyEntryStorageWrapper.clear()}))}updateRecipients(e){return n(this,void 0,void 0,(function*(){const{newPrivateKey:t,newPublicKeys:i}=e;return this.cloudKeyStorage.updateRecipients({newPrivateKey:t,newPublicKeys:i})}))}sync(){return n(this,void 0,void 0,(function*(){yield this.cloudKeyStorage.retrieveCloudEntries();const e=this.cloudKeyStorage.retrieveAllEntries(),t=e.reduce((e,t)=>(e[t.name]=t,e),{}),i=yield this.keyEntryStorageWrapper.list(),r=i.reduce((e,t)=>(e[t.name]=t,e),{}),n=[],s=[],o=[];return e.forEach(e=>{const t=r[e.name];if(t){const{modificationDate:i}=function(e){if(!e.meta)throw new TypeError("Invalid 'IKeyEntry'");return{creationDate:new Date(e.meta.k_cda),modificationDate:new Date(e.meta.k_mda)}}(t);if(e.modificationDate>i)return s.push(e.name)}else n.push(e.name)}),i.forEach(e=>{t[e.name]||o.push(e.name)}),this.syncKeyStorage(n,s,o)}))}throwUnlessKeyEntryExists(e){return n(this,void 0,void 0,(function*(){if(!(yield this.keyEntryStorageWrapper.exists(e)))throw new h(e)}))}throwIfKeyEntryExists(e){return n(this,void 0,void 0,(function*(){if(yield this.keyEntryStorageWrapper.exists(e))throw new d(e)}))}syncKeyStorage(e,t,i){return n(this,void 0,void 0,(function*(){const r=i.map(e=>n(this,void 0,void 0,(function*(){yield this.keyEntryStorageWrapper.remove(e)}))),s=t.map(e=>n(this,void 0,void 0,(function*(){const t=w(this.cloudKeyStorage.retrieveEntry(e));yield this.keyEntryStorageWrapper.update(t)}))),o=e.map(e=>n(this,void 0,void 0,(function*(){const t=w(this.cloudKeyStorage.retrieveEntry(e));yield this.keyEntryStorageWrapper.save(t)})));yield Promise.all([...r,...s,...o])}))}}export{c as CloudEntryDoesntExistError,y as CloudEntryExistsError,m as CloudGroupTicketStorage,f as CloudKeyStorage,a as CloudKeyStorageOutOfSyncError,u as GroupTicketAlreadyExistsError,l as GroupTicketDoesntExistError,v as GroupTicketNoAccessError,h as KeyEntryDoesntExistError,d as KeyEntryExistsError,p as KeyknoxClient,o as KeyknoxClientError,k as KeyknoxCrypto,s as KeyknoxError,g as KeyknoxManager,b as SyncKeyStorage};
