import { KeyknoxManager } from './KeyknoxManager';
import { ICrypto, IPrivateKey, IPublicKey, IAccessTokenProvider, Meta, CloudEntry, KeyEntry } from './types';
export declare class CloudKeyStorage {
    private readonly keyknoxManager;
    private privateKey;
    private publicKeys;
    private decryptedKeyknoxValue?;
    private cache;
    private syncWasCalled;
    constructor(keyknoxManager: KeyknoxManager, privateKey: IPrivateKey, publicKeys: IPublicKey | IPublicKey[]);
    static create(options: {
        accessTokenProvider: IAccessTokenProvider;
        privateKey: IPrivateKey;
        publicKeys: IPublicKey | IPublicKey[];
        virgilCrypto: ICrypto;
    }): CloudKeyStorage;
    storeEntries(keyEntries: KeyEntry[]): Promise<CloudEntry[]>;
    storeEntry(name: string, data: string, meta?: Meta): Promise<CloudEntry>;
    storeEntry(name: string, data: string, keyname?: string): Promise<CloudEntry>;
    updateEntry(name: string, data: string, meta?: Meta): Promise<CloudEntry>;
    retrieveEntry(name: string): CloudEntry;
    fetchEntryByKey(name: string, keyName: string): Promise<CloudEntry>;
    retrieveAllEntries(): CloudEntry[];
    existsEntry(name: string): boolean;
    deleteEntry(name: string): Promise<void>;
    deleteEntries(names: string[]): Promise<void>;
    deleteAllEntries(): Promise<void>;
    updateRecipients(options: {
        newPrivateKey?: IPrivateKey;
        newPublicKeys?: IPublicKey | IPublicKey[];
    }): Promise<void>;
    retrieveCloudEntries(): Promise<void>;
    private throwUnlessSyncWasCalled;
    private throwUnlessCloudEntryExists;
    private throwIfCloudEntryExists;
    private pushCacheEntries;
    private static createCloudEntry;
}
