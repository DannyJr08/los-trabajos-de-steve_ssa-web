'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var initPythiaModules = _interopDefault(require('@virgilsecurity/core-pythia'));
var initUtils = require('@virgilsecurity/init-utils');
var dataUtils = require('@virgilsecurity/data-utils');

const moduleInitializer = new initUtils.ModuleInitializer();
moduleInitializer.addModule('pythia', initPythiaModules);
moduleInitializer.on('load', (name, modules) => {
    if (name === 'pythia') {
        try {
            modules.Pythia.configure();
        }
        catch (error) {
            modules.Pythia.cleanup();
            throw error;
        }
    }
});
moduleInitializer.on('remove', (name, modules) => {
    if (name === 'pythia') {
        modules.Pythia.cleanup();
    }
});
const hasPythiaModules = () => moduleInitializer.hasModule('pythia');
const getPythiaModules = () => moduleInitializer.getModule('pythia');
const setPythiaModules = (pythiaModules) => {
    moduleInitializer.setModule('pythia', pythiaModules);
};
const initPythia = moduleInitializer.loadModules;

class VirgilBrainKeyCrypto {
    blind(password) {
        const { Pythia } = getPythiaModules();
        const myPassword = dataUtils.dataToUint8Array(password, 'utf8');
        const { blindedPassword, blindingSecret } = Pythia.blind(myPassword);
        return {
            blindedPassword: dataUtils.toBuffer(blindedPassword),
            blindingSecret: dataUtils.toBuffer(blindingSecret),
        };
    }
    deblind(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindingSecret = dataUtils.dataToUint8Array(options.blindingSecret, 'base64');
        const result = Pythia.deblind(myTransformedPassword, myBlindingSecret);
        return dataUtils.toBuffer(result);
    }
}

class VirgilPythiaCrypto {
    constructor(virgilBrainKeyCrypto) {
        this.virgilBrainKeyCrypto = virgilBrainKeyCrypto || new VirgilBrainKeyCrypto();
    }
    blind(password) {
        return this.virgilBrainKeyCrypto.blind(password);
    }
    deblind(options) {
        return this.virgilBrainKeyCrypto.deblind(options);
    }
    computeTransformationKeyPair(options) {
        const { Pythia } = getPythiaModules();
        const myTransformationKeyId = dataUtils.dataToUint8Array(options.transformationKeyId, 'base64');
        const myPythiaSecret = dataUtils.dataToUint8Array(options.pythiaSecret, 'base64');
        const myPythiaScopeSecret = dataUtils.dataToUint8Array(options.pythiaScopeSecret, 'base64');
        const { transformationPrivateKey, transformationPublicKey, } = Pythia.computeTransformationKeyPair(myTransformationKeyId, myPythiaSecret, myPythiaScopeSecret);
        return {
            privateKey: dataUtils.toBuffer(transformationPrivateKey),
            publicKey: dataUtils.toBuffer(transformationPublicKey),
        };
    }
    transform(options) {
        const { Pythia } = getPythiaModules();
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataUtils.dataToUint8Array(options.tweak, 'base64');
        const myTransformationPrivateKey = dataUtils.dataToUint8Array(options.transformationPrivateKey, 'base64');
        const { transformedPassword, transformedTweak } = Pythia.transform(myBlindedPassword, myTweak, myTransformationPrivateKey);
        return {
            transformedPassword: dataUtils.toBuffer(transformedPassword),
            transformedTweak: dataUtils.toBuffer(transformedTweak),
        };
    }
    prove(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTransformedTweak = dataUtils.dataToUint8Array(options.transformedTweak, 'base64');
        const { proofValueC, proofValueU } = Pythia.prove(myTransformedPassword, myBlindedPassword, myTransformedTweak, options.transformationKeyPair.privateKey, options.transformationKeyPair.publicKey);
        return {
            proofValueC: dataUtils.toBuffer(proofValueC),
            proofValueU: dataUtils.toBuffer(proofValueU),
        };
    }
    verify(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataUtils.dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataUtils.dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataUtils.dataToUint8Array(options.tweak, 'base64');
        const myTransformationPublicKey = dataUtils.dataToUint8Array(options.transformationPublicKey, 'base64');
        const myProofValueC = dataUtils.dataToUint8Array(options.proofValueC, 'base64');
        const myProofValueU = dataUtils.dataToUint8Array(options.proofValueU, 'base64');
        return Pythia.verify(myTransformedPassword, myBlindedPassword, myTweak, myTransformationPublicKey, myProofValueC, myProofValueU);
    }
    getPasswordUpdateToken(options) {
        const { Pythia } = getPythiaModules();
        const myOldTransformationPrivateKey = dataUtils.dataToUint8Array(options.oldTransformationPrivateKey, 'base64');
        const myNewTransformationPrivateKey = dataUtils.dataToUint8Array(options.newTransformationPrivateKey, 'base64');
        const passwordUpdateToken = Pythia.getPasswordUpdateToken(myOldTransformationPrivateKey, myNewTransformationPrivateKey);
        return dataUtils.toBuffer(passwordUpdateToken);
    }
    updateDeblindedWithToken(options) {
        const { Pythia } = getPythiaModules();
        const myDeblindedPassword = dataUtils.dataToUint8Array(options.deblindedPassword, 'base64');
        const myUpdateToken = dataUtils.dataToUint8Array(options.updateToken, 'base64');
        const result = Pythia.updateDeblindedWithToken(myDeblindedPassword, myUpdateToken);
        return dataUtils.toBuffer(result);
    }
}

exports.VirgilBrainKeyCrypto = VirgilBrainKeyCrypto;
exports.VirgilPythiaCrypto = VirgilPythiaCrypto;
exports.getPythiaModules = getPythiaModules;
exports.hasPythiaModules = hasPythiaModules;
exports.initPythia = initPythia;
exports.moduleInitializer = moduleInitializer;
exports.setPythiaModules = setPythiaModules;
