import initPythiaModules from '@virgilsecurity/core-pythia';
import { ModuleInitializer } from '@virgilsecurity/init-utils';
import { dataToUint8Array, toBuffer } from '@virgilsecurity/data-utils';

const moduleInitializer = new ModuleInitializer();
moduleInitializer.addModule('pythia', initPythiaModules);
moduleInitializer.on('load', (name, modules) => {
    if (name === 'pythia') {
        try {
            modules.Pythia.configure();
        }
        catch (error) {
            modules.Pythia.cleanup();
            throw error;
        }
    }
});
moduleInitializer.on('remove', (name, modules) => {
    if (name === 'pythia') {
        modules.Pythia.cleanup();
    }
});
const hasPythiaModules = () => moduleInitializer.hasModule('pythia');
const getPythiaModules = () => moduleInitializer.getModule('pythia');
const setPythiaModules = (pythiaModules) => {
    moduleInitializer.setModule('pythia', pythiaModules);
};
const initPythia = moduleInitializer.loadModules;

class VirgilBrainKeyCrypto {
    blind(password) {
        const { Pythia } = getPythiaModules();
        const myPassword = dataToUint8Array(password, 'utf8');
        const { blindedPassword, blindingSecret } = Pythia.blind(myPassword);
        return {
            blindedPassword: toBuffer(blindedPassword),
            blindingSecret: toBuffer(blindingSecret),
        };
    }
    deblind(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindingSecret = dataToUint8Array(options.blindingSecret, 'base64');
        const result = Pythia.deblind(myTransformedPassword, myBlindingSecret);
        return toBuffer(result);
    }
}

class VirgilPythiaCrypto {
    constructor(virgilBrainKeyCrypto) {
        this.virgilBrainKeyCrypto = virgilBrainKeyCrypto || new VirgilBrainKeyCrypto();
    }
    blind(password) {
        return this.virgilBrainKeyCrypto.blind(password);
    }
    deblind(options) {
        return this.virgilBrainKeyCrypto.deblind(options);
    }
    computeTransformationKeyPair(options) {
        const { Pythia } = getPythiaModules();
        const myTransformationKeyId = dataToUint8Array(options.transformationKeyId, 'base64');
        const myPythiaSecret = dataToUint8Array(options.pythiaSecret, 'base64');
        const myPythiaScopeSecret = dataToUint8Array(options.pythiaScopeSecret, 'base64');
        const { transformationPrivateKey, transformationPublicKey, } = Pythia.computeTransformationKeyPair(myTransformationKeyId, myPythiaSecret, myPythiaScopeSecret);
        return {
            privateKey: toBuffer(transformationPrivateKey),
            publicKey: toBuffer(transformationPublicKey),
        };
    }
    transform(options) {
        const { Pythia } = getPythiaModules();
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataToUint8Array(options.tweak, 'base64');
        const myTransformationPrivateKey = dataToUint8Array(options.transformationPrivateKey, 'base64');
        const { transformedPassword, transformedTweak } = Pythia.transform(myBlindedPassword, myTweak, myTransformationPrivateKey);
        return {
            transformedPassword: toBuffer(transformedPassword),
            transformedTweak: toBuffer(transformedTweak),
        };
    }
    prove(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTransformedTweak = dataToUint8Array(options.transformedTweak, 'base64');
        const { proofValueC, proofValueU } = Pythia.prove(myTransformedPassword, myBlindedPassword, myTransformedTweak, options.transformationKeyPair.privateKey, options.transformationKeyPair.publicKey);
        return {
            proofValueC: toBuffer(proofValueC),
            proofValueU: toBuffer(proofValueU),
        };
    }
    verify(options) {
        const { Pythia } = getPythiaModules();
        const myTransformedPassword = dataToUint8Array(options.transformedPassword, 'base64');
        const myBlindedPassword = dataToUint8Array(options.blindedPassword, 'base64');
        const myTweak = dataToUint8Array(options.tweak, 'base64');
        const myTransformationPublicKey = dataToUint8Array(options.transformationPublicKey, 'base64');
        const myProofValueC = dataToUint8Array(options.proofValueC, 'base64');
        const myProofValueU = dataToUint8Array(options.proofValueU, 'base64');
        return Pythia.verify(myTransformedPassword, myBlindedPassword, myTweak, myTransformationPublicKey, myProofValueC, myProofValueU);
    }
    getPasswordUpdateToken(options) {
        const { Pythia } = getPythiaModules();
        const myOldTransformationPrivateKey = dataToUint8Array(options.oldTransformationPrivateKey, 'base64');
        const myNewTransformationPrivateKey = dataToUint8Array(options.newTransformationPrivateKey, 'base64');
        const passwordUpdateToken = Pythia.getPasswordUpdateToken(myOldTransformationPrivateKey, myNewTransformationPrivateKey);
        return toBuffer(passwordUpdateToken);
    }
    updateDeblindedWithToken(options) {
        const { Pythia } = getPythiaModules();
        const myDeblindedPassword = dataToUint8Array(options.deblindedPassword, 'base64');
        const myUpdateToken = dataToUint8Array(options.updateToken, 'base64');
        const result = Pythia.updateDeblindedWithToken(myDeblindedPassword, myUpdateToken);
        return toBuffer(result);
    }
}

export { VirgilBrainKeyCrypto, VirgilPythiaCrypto, getPythiaModules, hasPythiaModules, initPythia, moduleInitializer, setPythiaModules };
