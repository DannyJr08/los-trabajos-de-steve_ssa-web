import axios from 'axios';
import { VirgilAgent } from 'virgil-sdk';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

class BrainKey {
    constructor(options) {
        this.crypto = options.crypto;
        this.brainKeyCrypto = options.brainKeyCrypto;
        this.pythiaClient = options.pythiaClient;
        this.keyPairType = options.keyPairType;
    }
    generateKeyPair(password, brainKeyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { blindedPassword, blindingSecret } = this.brainKeyCrypto.blind(password);
            const seed = yield this.pythiaClient.generateSeed(blindedPassword.toString('base64'), brainKeyId);
            const deblindedPassword = this.brainKeyCrypto.deblind({
                blindingSecret,
                transformedPassword: seed,
            });
            return this.crypto.generateKeysFromKeyMaterial(deblindedPassword, this.keyPairType);
        });
    }
}

class BreachProofPassword {
    constructor(salt, deblindedPassword, version) {
        this.salt = BreachProofPassword.valueToString(salt);
        this.deblindedPassword = BreachProofPassword.valueToString(deblindedPassword);
        this.version = version;
    }
    toJSON() {
        return {
            salt: this.salt,
            deblindedPassword: this.deblindedPassword,
            version: this.version,
        };
    }
    static valueToString(value) {
        if (typeof value === 'string') {
            return value;
        }
        return value.toString('base64');
    }
}

class PythiaError extends Error {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    constructor(message, name = 'PythiaError', DerivedClass = PythiaError) {
        super(message);
        Object.setPrototypeOf(this, DerivedClass.prototype);
        this.name = name;
    }
}
class PythiaClientError extends PythiaError {
    constructor(message, code, httpStatus) {
        super(message, 'PythiaClientError', PythiaClientError);
        this.code = code;
        this.httpStatus = httpStatus;
    }
}
class ProofVerificationFailedError extends PythiaError {
    constructor() {
        super('Transformed password proof verification has failed', 'ProofVerificationFailedError', ProofVerificationFailedError);
    }
}
class UnexpectedBreachProofPasswordVersionError extends PythiaError {
    constructor(expectedVersion, actualVersion) {
        super(`Unexpected Breach-proof password version. Expected ${expectedVersion}, got ${actualVersion}`, 'UnexpectedBreachProofPasswordVersionError', UnexpectedBreachProofPasswordVersionError);
    }
}

class PythiaClient {
    constructor(accessTokenProvider, apiUrl, virgilAgent) {
        if (accessTokenProvider == null) {
            throw new Error('`accessTokenProvider` is required');
        }
        this.accessTokenProvider = accessTokenProvider;
        this.axios = axios.create({ baseURL: apiUrl || PythiaClient.DEFAULT_URL });
        this.virgilAgent =
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            virgilAgent || new VirgilAgent("pythia", "1.0.2");
        this.axios.interceptors.response.use(undefined, PythiaClient.onBadResponse);
    }
    generateSeed(blindedPassword, brainKeyId) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                // eslint-disable-next-line @typescript-eslint/camelcase
                blinded_password: blindedPassword,
            };
            if (brainKeyId) {
                // eslint-disable-next-line @typescript-eslint/camelcase
                body.brainkey_id = brainKeyId;
            }
            const accessToken = yield this.accessTokenProvider.getToken({
                service: 'pythia',
                operation: 'seed',
            });
            const { data: { seed }, } = yield this.axios.post('/pythia/v1/brainkey', body, {
                headers: PythiaClient.getHeaders(this.virgilAgent, accessToken),
            });
            return seed;
        });
    }
    transformPassword(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = {
                // eslint-disable-next-line @typescript-eslint/camelcase
                blinded_password: options.blindedPassword,
                // eslint-disable-next-line @typescript-eslint/camelcase
                user_id: options.salt,
            };
            if (typeof options.version === 'number' && !Number.isNaN(options.version)) {
                body.version = options.version;
            }
            if (typeof options.includeProof === 'boolean') {
                // eslint-disable-next-line @typescript-eslint/camelcase
                body.include_proof = options.includeProof;
            }
            const accessToken = yield this.accessTokenProvider.getToken({
                service: 'pythia',
                operation: 'password',
            });
            const { 
            // eslint-disable-next-line @typescript-eslint/camelcase
            data: { transformed_password, proof }, } = yield this.axios.post('/pythia/v1/password', body, {
                headers: PythiaClient.getHeaders(this.virgilAgent, accessToken),
            });
            const result = {
                // eslint-disable-next-line @typescript-eslint/camelcase
                transformedPassword: transformed_password,
            };
            if (body.include_proof) {
                result.proof = {
                    valueC: proof.value_c,
                    valueU: proof.value_u,
                };
            }
            return result;
        });
    }
    static getHeaders(virgilAgent, accessToken) {
        return {
            Authorization: `Virgil ${accessToken.toString()}`,
            'Virgil-Agent': virgilAgent.value,
        };
    }
    static onBadResponse(error) {
        if (error.response) {
            if (error.response.data) {
                const message = error.response.data.message || error.response.statusText;
                throw new PythiaClientError(message, error.response.data.code, error.response.status);
            }
            throw new PythiaClientError(error.response.statusText, undefined, error.response.status);
        }
        throw new PythiaError('Something bad happened. Please try again later.');
    }
}
PythiaClient.DEFAULT_URL = 'https://api.virgilsecurity.com';

/* eslint-disable no-console */
const createBrainKey = (options) => {
    const pythiaClient = new PythiaClient(options.accessTokenProvider, options.apiUrl);
    if (options.virgilPythiaCrypto && console && console.warn) {
        console.warn('Option `virgilPythiaCrypto` is deprecated. Use `virgilBrainKeyCrypto` instead.');
    }
    return new BrainKey({
        pythiaClient,
        crypto: options.virgilCrypto,
        brainKeyCrypto: options.virgilBrainKeyCrypto || options.virgilPythiaCrypto,
        keyPairType: options.keyPairType,
    });
};

const constantTimeEqual = (a, b) => {
    if (typeof a !== 'string' || typeof b !== 'string')
        return false;
    let mismatch = a.length === b.length ? 0 : 1;
    if (mismatch) {
        b = a;
    }
    for (let i = 0, il = a.length; i < il; ++i) {
        mismatch |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return mismatch === 0;
};
const toArray = (val) => {
    return val == null ? [] : Array.isArray(val) ? val : [val];
};

class ProofKeys {
    constructor(proofKeys) {
        const myProofKeys = toArray(proofKeys);
        if (!myProofKeys.length) {
            throw new Error('`proofKeys` must not be empty');
        }
        this.proofKeys = myProofKeys.map(this.parseProofKey).sort(this.compareProofKeyVersions);
    }
    currentKey() {
        if (this.proofKeys[0] === undefined) {
            throw new Error('No proof key exists');
        }
        return this.proofKeys[0];
    }
    proofKey(version) {
        const proofKey = this.proofKeys.find(proofKey => proofKey.version === version);
        if (proofKey === undefined) {
            throw new Error(`Proof key of version ${version} does not exist`);
        }
        return proofKey;
    }
    parseProofKey(proofKey) {
        const parts = proofKey.split('.');
        if (parts.length !== 3 || parts[0] !== 'PK') {
            throw new TypeError('`proofKey` format is invalid');
        }
        const version = Number(parts[1]);
        const key = parts[2];
        return { version, key };
    }
    compareProofKeyVersions(proofKey1, proofKey2) {
        return proofKey2.version - proofKey1.version;
    }
}

class Pythia {
    constructor(options) {
        this.crypto = options.crypto;
        this.proofKeys = options.proofKeys;
        this.pythiaClient = options.pythiaClient;
        this.pythiaCrypto = options.pythiaCrypto;
    }
    verifyBreachProofPassword(password, breachProofPassword, includeProof) {
        return __awaiter(this, void 0, void 0, function* () {
            const { blindedPassword, blindingSecret } = this.pythiaCrypto.blind(password);
            const proofKey = this.proofKeys.proofKey(breachProofPassword.version);
            const { transformedPassword, proof } = yield this.pythiaClient.transformPassword({
                includeProof,
                blindedPassword: blindedPassword.toString('base64'),
                salt: breachProofPassword.salt,
                version: breachProofPassword.version,
            });
            if (includeProof) {
                const verified = this.pythiaCrypto.verify({
                    transformedPassword,
                    blindedPassword,
                    tweak: breachProofPassword.salt,
                    transformationPublicKey: proofKey.key,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    proofValueC: proof.valueC,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    proofValueU: proof.valueU,
                });
                if (!verified) {
                    throw new ProofVerificationFailedError();
                }
            }
            const deblindedPassword = this.pythiaCrypto.deblind({ transformedPassword, blindingSecret });
            return constantTimeEqual(deblindedPassword.toString('base64'), breachProofPassword.deblindedPassword);
        });
    }
    createBreachProofPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const salt = this.crypto.getRandomBytes(Pythia.SALT_BYTE_LENGTH);
            const { blindedPassword, blindingSecret } = this.pythiaCrypto.blind(password);
            const latestProofKey = this.proofKeys.currentKey();
            const { transformedPassword, proof } = yield this.pythiaClient.transformPassword({
                blindedPassword: blindedPassword.toString('base64'),
                salt: salt.toString('base64'),
                version: latestProofKey.version,
                includeProof: true,
            });
            const verified = this.pythiaCrypto.verify({
                transformedPassword,
                blindedPassword,
                tweak: salt,
                transformationPublicKey: latestProofKey.key,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                proofValueC: proof.valueC,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                proofValueU: proof.valueU,
            });
            if (!verified) {
                throw new ProofVerificationFailedError();
            }
            const deblindedPassword = this.pythiaCrypto.deblind({ transformedPassword, blindingSecret });
            return new BreachProofPassword(salt, deblindedPassword, latestProofKey.version);
        });
    }
    updateBreachProofPassword(updateToken, breachProofPassword) {
        const { prevVersion, nextVersion, token } = this.parseUpdateToken(updateToken);
        if (breachProofPassword.version !== prevVersion) {
            throw new UnexpectedBreachProofPasswordVersionError(prevVersion, breachProofPassword.version);
        }
        const deblindedPassword = this.pythiaCrypto.updateDeblindedWithToken({
            deblindedPassword: breachProofPassword.deblindedPassword,
            updateToken: token,
        });
        return new BreachProofPassword(breachProofPassword.salt, deblindedPassword, nextVersion);
    }
    parseUpdateToken(updateToken) {
        const parts = updateToken.split('.');
        if (parts.length !== 4 || parts[0] !== 'UT') {
            throw new TypeError('`updateToken` format is invalid');
        }
        return {
            prevVersion: Number(parts[1]),
            nextVersion: Number(parts[2]),
            token: parts[3],
        };
    }
}
Pythia.SALT_BYTE_LENGTH = 32;

const createPythia = (options) => {
    const proofKeys = new ProofKeys(options.proofKeys);
    const pythiaClient = new PythiaClient(options.accessTokenProvider, options.apiUrl);
    return new Pythia({
        proofKeys,
        pythiaClient,
        crypto: options.virgilCrypto,
        pythiaCrypto: options.virgilPythiaCrypto,
    });
};

export { BrainKey, BreachProofPassword, ProofKeys, ProofVerificationFailedError, Pythia, PythiaClient, PythiaClientError, PythiaError, UnexpectedBreachProofPasswordVersionError, createBrainKey, createPythia };
